\field{物理数学}
\title{行列式のルール}
\comment{他にもあるが、<br>とりあえずはこれくらいで十分だ。}
\prev{linear02}
\next{linear04}
\create{2011/1/28}
\modify{}



\section{断り書き}

　これから行列式に関しての計算テクニックをまとめていきたいと思う。
　面倒な証明は読者に任せるという方針を取ってきたし、これからもそうするつもりである。
　となれば、これから述べる行列式の性質についてもわざわざ証明せずに、ただ列挙すれば済んでしまうことだろう。
　これから話すことはすべて、既に説明した定義から導かれることに過ぎないからだ。 

<P>

　しかしそれではあまりに味気ない。
　せめて読者に「自分でも何とか証明できそうだ」という気分になってもらわないと。
　それで私なりの説明手順というか、ストーリーを作ってみた。

<P>

　証明の方法は一つきりではないし、好みも人それぞれである。
　別の手順で進んだ方が効率が良いと思う人もあるだろう。
　ここでは私が選んだ道筋を楽しんでもらいたい。

% =======================================================================

\section{余因子展開}

　まずは教科書の中でも重要度が高いと思われるテクニックから片付けてしまおう。
　余因子展開と呼ばれるものだ。
　これが終われば残りはザコばかりである。

<P>

　そのためにはまず余因子とは何かという話をしておいた方が良い。

<P>

　$ n $次の正方行列を想像してほしい。
　これを行列$ A $と呼ぶことにしておこう。
　この行列から$ i $行目と$ j $列目を取っ払って、
残った部分を詰めてやると、$ n-1 $次の正方行列が出来上がるだろう。
　その行列式を計算すれば、ある値が得られる。
　その値にさらに$ (-1)^{(i+j)} $を掛けた値が、
「\red{行列}$ \color{red}{A} $\red{の}$ \color{red}{(i,j)} $\red{余因子}」である。

<P>

　これで余因子の説明は終わり。
　簡単だろう？
　$ (-1)^{(i+j)} $を掛けるというのがややこしく見えるかも知れないが、
$ (i,j) $が一番左上の要素だったら +1 で、その右なら -1 で、次は +1 で・・・となるだけだ。
　二行目だったら、一番左が -1 で、次が +1 で・・・という具合だ。

<P>

　余因子は行列$ A $の成分の数と同じだけ存在しているわけで、$ \tilde{a}_{ij} $という記号で表そう。
　これを使えば、$ A $の行列式$ |A| $は次のように展開して表すことができる。

<tex>
|A| \ &=\ a_{i1} \, \tilde{a}_{i1} \ +\ a_{i2} \, \tilde{a}_{i2} \ +\ \cdots \ +\ a_{in} \, \tilde{a}_{in} \\
&=\ \sum_{j=1}^{n} a_{ij} \, \tilde{a}_{ij}
</tex>

　なぜそんなことが出来るのか理解できないって？
　心配しなくていい。
　まだ説明していないからだ。
　気になるかな？

<P>

　この意味は簡単だ。
　好きな行$ i $をどこでも自由に決めて、横一列、それぞれの成分と余因子を掛け合わせたものを足していけば、
$ |A| $を計算したのと同じ結果になるというのである。

<P>

　これと同じことが列についても成り立っている。
　好きな列$ j $をどこでも勝手に決めて、縦一列、それぞれの成分と余因子を掛け合わせたものを足していけば、
やはり$ |A| $を計算したのと同じことになるのである。

<tex>
|A| \ &=\ a_{1j} \, \tilde{a}_{1j} \ +\ a_{2j} \, \tilde{a}_{2j} \ +\ \cdots \ +\ a_{nj} \, \tilde{a}_{nj} \\
&=\ \sum_{i=1}^{n} a_{ij} \, \tilde{a}_{ij} 
</tex>

　これが「\red{余因子展開}」と呼ばれる技だ。

<P>

　ところで、さっきから行列$ A $の行列式を$ |A| $と表していて、まるで絶対値みたいに思えるかも知れない。
　しかしこれは絶対値とは関係ない。
　たまたま記法がかぶってしまっただけだ。
　絶対値ではないので負の値だって取りうる。


% =======================================================================

\section{余因子展開の応用}

　余因子展開というのは$ n $次の行列式を計算するのが面倒なとき、
$ n-1 $次の行列式を$ n $個分だけ計算して和を取ればいいという便利なものだ。

<P>

　んーと？
　これは本当に得してると言えるのか？

<P>

　行列式の定義によれば、行列式を計算するためには$ n $個の並べ替えをすべて試みなければならず、
つまり合計$ n\,! $項の和を計算しなければならないのだった。
　ということは余因子展開を使ってみても、$ (n-1)\,! $項の和を$ n $回繰り返すわけだから、
「足し算の回数ではまったく得していない」ことになる。

<P>

　余因子展開が本当に役に立つのは、
ある列や、ある行に、0 になっている成分が多く含まれる場合だ。
　その部分は余因子をまったく計算しなくて済むことになるのだから。

<P>

　なるべく 0 が多く含まれる行か列を一つ見つけて余因子展開を試みる。
　それが正しい使い方だ。

<P>

　ある行、あるいは、ある列が全て 0 だったとしたら・・・。
　それはその行列の行列式は計算するまでもなく 0 だということを意味する。

<P>

　何か実例を挙げようと思っていたが、もうそんな必要もないほど分かり易いだろう？
　あ、そうだ、あれがいい。

% =======================================================================

\section{上三角行列に当てはめてみる}

　前に覚えておいて欲しいと言っておいた「上三角行列」をちゃんと覚えてくれているだろうか。

<tex>
\left(
\begin{array}{rrrr}
1 & 8 & 6 & 2 \\[4pt]
0 & \!\!\!-2 & 9 & 0 \\[4pt]
0 & 0 & 4 & 6 \\[4pt]
0 & 0 & 0 & 3 \\
\end{array}
\right)
</tex>

　この行列の行列式を余因子展開を利用して計算してみよう。

<P>

　まずは 0 の多く含まれる行か列を探す。
　この場合、4 行目か 1 列目だが・・・私の好みにより、1 列目をターゲットにする。
　$ (1,1) $成分の値は 1 であり、余因子は 1 行目と 1 列目を取り除いた残りの部分の行列式に +1 をかけたもの。
　次のように展開できる。
　まぁ、一つきりしか項がないから「展開」という雰囲気でもないけれども。

<tex>
\left|
\begin{array}{rrrr}
1 & 8 & 6 & 2 \\[4pt]
0 & \!\!\!-2 & 9 & 0 \\[4pt]
0 & 0 & 4 & 6 \\[4pt]
0 & 0 & 0 & 3 \\
\end{array}
\right|
\ =\ 
1 \times 
\left|
\begin{array}{rrr}
\!\!\!-2 & 9 & 0 \\[4pt]
0 & 4 & 6 \\[4pt]
0 & 0 & 3 \\
\end{array}
\right|
</tex>

　続いて、この右辺にある行列式を計算してみよう。
　0 が多いのは、先ほどと同じく 1 列目、あるいは 3 行目。
　好みにより、やはり 1 列目を狙う。

<tex>
\left|
\begin{array}{rrr}
\!\!\!-2 & 9 & 0 \\[4pt]
0 & 4 & 6 \\[4pt]
0 & 0 & 3 \\
\end{array}
\right|
\ =\ 
-2 \times
\left|
\begin{array}{rr}
4 & 6 \\[4pt]
0 & 3 \\
\end{array}
\right|
</tex>

　もう最後までやらなくても分かってきただろう。
　\red{上三角行列の場合には、何次の場合であっても、対角成分の積だけを計算すれば行列式が計算できてしまう！}

<tex>
\left|
\begin{array}{rrrr}
1 & 8 & 6 & 2 \\[4pt]
0 & \!\!\!-2 & 9 & 0 \\[4pt]
0 & 0 & 4 & 6 \\[4pt]
0 & 0 & 0 & 3 \\
\end{array}
\right|
\ =\ 1 \times (-2) \times 4 \times 3
</tex>

　行列式を計算する場面で上三角行列に出会ったらとってもラッキーだということだ。

<P>

　うーん、怪しいな・・・。
　そんな偶然の機会などそうそうあるもんじゃないだろう。
　それなのに、わざわざ時間を犠牲にしてまで上三角行列の行列式を求める方法をここで紹介するのは効率が悪い気がする。
　するだろう？！
　何か裏があるに違いない。
　前回の話でも普通の行列を素早く上三角行列に変形していく方法を強調していたではないか。

<P>

　しかし行列を上三角行列に変形する過程で行列式の値は次々に変わってしまうだろう。
　え？
　ひょっとして変わらないとか？
　さーて、どうだろうかね。
　その話は後にしよう。

% =======================================================================

\section{行で成り立つことは列でも成り立つ}

　話を進める前に、このような技が使えることを証明してみたいという賢明な読者のサポートをしておかなくては・・・。

<P>

　その証明に取り掛かる前に、次のことを証明しておくと効率がいいかもしれない。
　それは「\red{行列式の計算において、行で成り立つことは列についてもそのまま成り立っている}」というものだ。

<P>

　次の式の左辺は以前にも書いた行列式の定義だが、右辺では行と列の成分を入れ替えてある。

<tex>
     \sum_\sigma \big[ \mathrm{sgn}(\sigma) \ a_{1\,\sigma(1)} \ a_{2\,\sigma(2)} \cdots a_{n\,\sigma(n)} \big]
\ =\ \sum_\sigma \big[ \mathrm{sgn}(\sigma') \ a_{\sigma'(1)\,1} \ a_{\sigma'(2)\,2} \cdots a_{\sigma'(n)\,n} \big]
</tex>

　この等式が証明できれば、行と列の役割を入れ替えて計算しても行列式の計算結果は変わらないことが言える。

<P>

　左辺を見ると、列を表す部分に$ \sigma(1) \cdots \sigma(n) $が使われているが、
これは 1 ～ n の数字をばらばらにしたものなので、右辺のように並べ直してやることができる。
　そのときに行を表す数字がばらばらになるので、
右辺では$ \sigma'(1) \cdots \sigma'(n) $のように表してある。
　それを何回の交換作業で元に戻せるかによって符号が決まるのが右辺の$ \mathrm{sgn}(\sigma') $の部分である。
　それは左辺の$ \mathrm{sgn}(\sigma) $と同じではないだろうか。
　バラバラにする作業と、元に戻す作業は同じ回数で終えられるはずだからだ。

<P>

　これで証明できてしまった。
　これだけの説明では分かりにくいかもしれないが、
もともとは読者に任せようと思っていた部分だからこれ以上親切に書くつもりもない。
　気になる人はじっくり考えてみてもらいたい。

<P>

　これによって、余因子展開についての証明も、行か、列か、どちらかの式を証明するだけで良いと言えるだろう。
　手間が半減するわけだ。


% =======================================================================

\section{ある行または列を定数倍すると・・・}

　余因子展開の証明をするためには行列式の他の性質も知っておいた方が助けになるだろう。

<P>

　例えば「\red{ある一つの列を}$ \color{red}{k} $\red{倍すると、行列式も}$ \color{red}{k} $\red{倍になる}」という性質はどうだろう。

<P>

　これは行列式の定義を思い出せば簡単に分かることだ。
　上から順番に、同じ列の成分を選ばないように掛け合わせていったものを足し合わせるのであった。
　つまり、各項には必ず一つだけ、$ k $倍された成分が混じるのである。
　それらを足し合わせるのだから、結果として全体が$ k $倍されるのは当然というわけだ。

<P>

　先ほど証明した「行で成り立つことは列でも成り立つ」という論理によって、この話は行についても成り立っていると言える。
　つまり、「\red{ある一つの行を}$ \color{red}{k} $\red{倍すると、行列式も}$ \color{red}{k} $\red{倍になる}」と言えるわけだ。

% =======================================================================

\section{ある行または列を和で表すと・・・}

　知っておいた方がいいことはまだある。
　次のような関係が成り立っている。

<tex>
\left|
\begin{array}{ccccc}
a_{11} & \cdots & a'_{1j} + a''_{1j} & \cdots & a_{1n} \\[3pt]
a_{21} & \cdots & a'_{2j} + a''_{2j} & \cdots & a_{2n} \\[3pt]
\vdots & \cdots & \vdots             & \cdots & \vdots \\[3pt]
a_{n1} & \cdots & a'_{nj} + a''_{nj} & \cdots & a_{nn} \\
\end{array}
\!\right|
\ =\ 
\left|
\begin{array}{ccccc}
a_{11} & \cdots & a'_{1j} & \cdots & a_{1n} \\[3pt]
a_{21} & \cdots & a'_{2j} & \cdots & a_{2n} \\[3pt]
\vdots & \cdots & \vdots  & \cdots & \vdots \\[3pt]
a_{n1} & \cdots & a'_{nj} & \cdots & a_{nn} \\
\end{array}
\!\right|
\ +\ 
\left|
\begin{array}{ccccc}
a_{11} & \cdots & a''_{1j} & \cdots & a_{1n} \\[3pt]
a_{21} & \cdots & a''_{2j} & \cdots & a_{2n} \\[3pt]
\vdots & \cdots & \vdots   & \cdots & \vdots \\[3pt]
a_{n1} & \cdots & a''_{nj} & \cdots & a_{nn} \\
\end{array}
\!\right|
</tex>

　「\red{ある列を和の形で表したものは二つの行列式の和で表せる}」というものだ。
　もう少し正確に表現してみると、ある列を$ a'_{ij} + a''_{ij} $という和の形で表した行列の行列式は、
その列を$ a'_{ij} $に置き換えた行列と、$ a''_{ij} $に置き換えた行列の二つの行列式の和で表せる。

<P>

　この証明も先ほどと似たようなもので、行列式の定義を思い出せば理解できるだろう。
　各項に必ず一つ、和で表された成分を掛ける部分が入るからそれを展開してやって二つに分けてやれるというわけだ。

<P>

　これも先ほど証明したことによって、行についても成り立っている。
　つまり、「\red{ある行を和の形で表したものは二つの行列式の和で表せる}」とも言えるわけだ。

% =======================================================================

\section{二つの行または二つの列を入れ替えると・・・}

　最後にもうひとつ。
　「\red{二つの列を入れ替えると行列式は -1 倍される}」という性質がある。
　これも行列式の定義を思い出せば簡単に理解できるだろう。
　列が入れ替わるという事は、$ \mathrm{sgn}(\sigma) $の符号がどの項についても反転することを意味するからだ。

<P>

　これも先ほど証明したことによって、行についても成り立っている。
　つまり、「\red{二つの行を入れ替えると行列式は -1 倍される}」と言える。

% =======================================================================

\section{余因子展開の証明}

　準備が整ったのでこれから余因子展開の証明の手順を書こうと思うのだが、
どうやら無計画に準備し過ぎてしまったらしい。
　良く良く落ち着いて考えて見れば、後の方の二つの性質しか使わなくて済みそうだ。
　まぁ、無駄にはなるまい。

<P>

　$ j $列目に注目して展開する状況を考えてみよう。
　$ j $列目を次のように和の形に分けてやる。

<tex>
\left|
\begin{array}{ccccc}
a_{11} & \cdots & a_{1j} & \cdots & a_{1n} \\[3pt]
a_{21} & \cdots & a_{2j} & \cdots & a_{2n} \\[3pt]
\vdots & \cdots & \vdots             & \cdots & \vdots \\[3pt]
a_{n1} & \cdots & a_{nj} & \cdots & a_{nn} \\
\end{array}
\!\right|
\ =\ 
\left|
\begin{array}{ccccc}
a_{11} & \cdots & (a_{1j} +\ 0\ \,+ 0 + \cdots +\ 0\,\ ) & \cdots & a_{1n} \\[3pt]
a_{21} & \cdots & (\,\ 0 \ + a_{2j} + 0 + \cdots +\ 0\,\ ) & \cdots & a_{2n} \\[3pt]
\vdots & \cdots & \vdots             & \cdots & \vdots \\[3pt]
a_{n1} & \cdots & (\,\ 0\ +\ 0\ + 0 + \cdots + a_{nj}) & \cdots & a_{nn} \\
\end{array}
\!\right|
</tex>

　これは多数の行列式に分解できるはずだ。

<tex>
=\ 
\left|
\begin{array}{ccccc}
a_{11} & \cdots & a_{1j} & \cdots & a_{1n} \\[3pt]
a_{21} & \cdots & 0      & \cdots & a_{2n} \\[3pt]
\vdots & \cdots & \vdots & \cdots & \vdots \\[3pt]
a_{n1} & \cdots & 0      & \cdots & a_{nn} \\
\end{array}
\!\right|
\ +\ 
\left|
\begin{array}{ccccc}
a_{11} & \cdots & 0      & \cdots & a_{1n} \\[3pt]
a_{21} & \cdots & a_{2j} & \cdots & a_{2n} \\[3pt]
\vdots & \cdots & \vdots & \cdots & \vdots \\[3pt]
a_{n1} & \cdots & 0      & \cdots & a_{nn} \\
\end{array}
\!\right|
\ +\ \cdots
\ +\ 
\left|
\begin{array}{ccccc}
a_{11} & \cdots & 0 & \cdots & a_{1n} \\[3pt]
a_{21} & \cdots & 0 & \cdots & a_{2n} \\[3pt]
\vdots & \cdots & \vdots             & \cdots & \vdots \\[3pt]
a_{n1} & \cdots & a_{nj} & \cdots & a_{nn} \\
\end{array}
\!\right|
</tex>

　この全ての項の$ j $列目を一番左の列に持ってくることを考える。
　ただ無条件に移動させたいだけならば 1 列目との一回きりの列の交換で済むのだろうが、
$ j $列以外の並び順を変えたくないので、隣へ隣へと$ j-1 $回の交換を繰り返すことで実現しよう。

<tex>
=\ (-1)^{j-1}
\left|
\begin{array}{cccc}
a_{1j} & a_{11} & \cdots & a_{1n} \\[3pt]
0      & a_{21} & \cdots & a_{2n} \\[3pt]
\vdots & \vdots & \vdots & \vdots \\[3pt]
0      & a_{n1} & \cdots & a_{nn} \\
\end{array}
\!\right|
\ +\ (-1)^{j-1}
\left|
\begin{array}{cccc}
0      & a_{11} & \cdots & a_{1n} \\[3pt]
a_{2j} & a_{21} & \cdots & a_{2n} \\[3pt]
\vdots & \vdots & \vdots & \vdots \\[3pt]
0      & a_{n1} & \cdots & a_{nn} \\
\end{array}
\!\right|
 + \cdots + (-1)^{j-1}
\left|
\begin{array}{ccccc}
0      & a_{11} & \cdots & a_{1n} \\[3pt]
0      & a_{21} & \cdots & a_{2n} \\[3pt]
\vdots & \vdots & \vdots & \vdots \\[3pt]
a_{nj} &a_{n1}  & \cdots & a_{nn} \\
\end{array}
\!\right|
</tex>

　出来た。
　この式のそれぞれの項の一番左にある列に注目して欲しい。
　今度はこれらの列の 0 でない要素が一番上に来るように行を移動させたい。
　ただし他の行の順番は崩さないようにするために、一つずつ交換しながら上がってくるようにする。
　つまり、最初の項についてはそのままでいいが、2 番目の項は 1 回、3 番目の項は 2 回、$ n $番目の項は$ n-1 $回の行の交換を経ることになる。

<tex>
=\ (-1)^{j-1}
\left|
\begin{array}{cccc}
a_{1j} & a_{11} & \cdots & a_{1n} \\[3pt]
0      & a_{21} & \cdots & a_{2n} \\[3pt]
\vdots & \vdots & \vdots & \vdots \\[3pt]
0      & a_{n1} & \cdots & a_{nn} \\
\end{array}
\!\right|
\ +\ (-1)^{j}
\left|
\begin{array}{cccc}
a_{2j} & a_{21} & \cdots & a_{2n} \\[3pt]
0      & a_{11} & \cdots & a_{1n} \\[3pt]
\vdots & \vdots & \vdots & \vdots \\[3pt]
0      & a_{n1} & \cdots & a_{nn} \\
\end{array}
\!\right|
 + \cdots + (-1)^{j + n - 2}
\left|
\begin{array}{cccc}
a_{nj} &a_{n1}  & \cdots & a_{nn} \\[3pt]
0      & a_{11} & \cdots & a_{1n} \\[3pt]
\vdots & \vdots & \vdots & \vdots \\[3pt]
0      & a_{n-1\,1} & \cdots & a_{n-1\,n} \\
\end{array}
\!\right|
</tex>

　さあ、出来たぞ。
　これらの各項の行列式を計算することを考えてみて欲しい。
　行列式の定義を思い出そう。
　一行目から順に、成分を一つずつ選んで掛けてゆくのだった。
　しかし今回の場合、一行目からは必ず一列目にある成分を選ばないといけないことになる。
　そうしないと、いずれは一列目から選ばないといけないことになるが、そこには 0 しか残されていないので結局は消えてしまう運命なのである。
　つまり生き残れるのは、必ず最初に左上にある成分を選んだ場合の項だけである。

<P>

　一行目から左上の成分を選んだ後は好きに選べばいい。
　それは一列目と一行目を取っ払った行列についての行列式を計算するのと同じ手順ではないか。
　だから次のように書き直せるだろう。
　ついでに各項の先頭に$ (-1)^2 $を掛けて、分かり易いように調整しておいてやろう。

<tex>
=\ a_{1j} (-1)^{j+1}
\left|
\begin{array}{ccc}
a_{21} & \cdots & a_{2n} \\[3pt]
\vdots & \vdots & \vdots \\[3pt]
a_{n1} & \cdots & a_{nn} \\
\end{array}
\!\right|
\ +\ a_{2j}(-1)^{j+2}
\left|
\begin{array}{ccc}
a_{11} & \cdots & a_{1n} \\[3pt]
\vdots & \vdots & \vdots \\[3pt]
a_{n1} & \cdots & a_{nn} \\
\end{array}
\!\right|
 + \cdots + a_{nj}(-1)^{j+n}
\left|
\begin{array}{cccc}
a_{11} & \cdots & a_{1n} \\[3pt]
\vdots & \vdots & \vdots \\[3pt]
a_{n-1\,1} & \cdots & a_{n-1\,n} \\
\end{array}
\!\right|
</tex>

　これはまさに余因子展開の式である。
　ということで、ヒントだけを示すつもりが、結局最後まで証明することになってしまった。

<P>

　\red{まぁ、こんなものは興味がなければ読み飛ばしてくれても良かったのだ。}
　余因子展開が魔法でも何でもない事を理解さえしてくれたなら。

% =======================================================================

\section{同じ中身の列、または行が存在していると・・・}

　さて、これで余因子展開の話は一区切りだ。
　そういえば、普通の行列を上三角行列に変形する過程で行列式がどう変化するかという事にちょっと関心が向いたのだった。
　次にその辺りを説明してみよう。

<P>

　とは言うものの、すでに「ある行を定数倍」した場合と、
「二つの行を入れ替え」した場合に行列式がどう変化するかということについては説明済みだ。
　すると、行列の変形で許されたルールとして残るはただ一つ。
　「ある行を定数倍したものを別の行に加える」ことである。
　この時、行列式はどう変化するのだろうか。

<P>

　これを説明するために、もう一つだけ知っておくと便利だ。

<P>

　すでに「二つの列を入れ替えると行列式は -1 倍される」という性質を確認している。
　初めに行列式の値が$ a $だとしたら、入れ替え後は$ -a $だというわけだ。
　しかしそこでもし二つの列の中身が全く同じだったとしたら、それらを入れ替えても、入れ替える前と何も変わらない。
　つまり$ a = -a $が成り立つことになる。
　この条件を満たすのは、$ a = 0 $の場合だけである。
　よって「\red{全く同じ中身の列が存在していればその行列式は 0 である}」と言える。

<P>

　行についても同じことが成り立っており、
「\red{中身が全く同じ行が存在していればその行列式は 0 である}」と言える。


% =======================================================================

\section{ある列を定数倍したものを別の列に加えたら・・・}

　ではいよいよ、「ある列を定数倍したものを別の列に加えたら」行列式の値がどうなるかを見てみよう。

<P>

　言葉で説明するより式を見た方が早い。
　例えば、$ i $列目を$ k $倍して$ j $列目に加える様子を式変形で見てみよう。

<tex>
&
\left|
\begin{array}{ccccccc}
a_{11} & \cdots & a_{1i} & \cdots & a_{1j} + k a_{1i} & \cdots & a_{1n} \\[3pt]
a_{21} & \cdots & a_{2i} & \cdots & a_{2j} + k a_{2i} & \cdots & a_{2n} \\[3pt]
\vdots &        & \vdots &        & \vdots            &        & \vdots \\[3pt]
a_{n1} & \cdots & a_{ni} & \cdots & a_{nj} + k a_{ni}& \cdots & a_{nn} \\
\end{array}
\!\right| \\[8pt]
&\ \ \ \ \ \ \ \ =\ 
\left|
\begin{array}{ccccccc}
a_{11} & \cdots & a_{1i} & \cdots & a_{1j} & \cdots & a_{1n} \\[3pt]
a_{21} & \cdots & a_{2i} & \cdots & a_{2j} & \cdots & a_{2n} \\[3pt]
\vdots &        & \vdots &        & \vdots &        & \vdots \\[3pt]
a_{n1} & \cdots & a_{ni} & \cdots & a_{nj} & \cdots & a_{nn} \\
\end{array}
\!\right|
\ +\ 
\left|
\begin{array}{ccccccc}
a_{11} & \cdots & a_{1i} & \cdots & k\,a_{1i} & \cdots & a_{1n} \\[3pt]
a_{21} & \cdots & a_{2i} & \cdots & k\,a_{2i} & \cdots & a_{2n} \\[3pt]
\vdots &        & \vdots &        & \vdots            &        & \vdots \\[3pt]
a_{n1} & \cdots & a_{ni} & \cdots & k\,a_{ni}& \cdots & a_{nn} \\
\end{array}
\!\right| \\[8pt]
&\ \ \ \ \ \ \ \ =\ 
\left|
\begin{array}{ccccccc}
a_{11} & \cdots & a_{1i} & \cdots & a_{1j} & \cdots & a_{1n} \\[3pt]
a_{21} & \cdots & a_{2i} & \cdots & a_{2j} & \cdots & a_{2n} \\[3pt]
\vdots &        & \vdots &        & \vdots &        & \vdots \\[3pt]
a_{n1} & \cdots & a_{ni} & \cdots & a_{nj} & \cdots & a_{nn} \\
\end{array}
\!\right|
\ +\ k\,
\left|
\begin{array}{ccccccc}
a_{11} & \cdots & \color{red}{a_{1i}} & \cdots & \color{red}{a_{1i}} & \cdots & a_{1n} \\[3pt]
a_{21} & \cdots & \color{red}{a_{2i}} & \cdots & \color{red}{a_{2i}} & \cdots & a_{2n} \\[3pt]
\vdots &        & \color{red}{\vdots} &        & \color{red}{\vdots} &        & \vdots \\[3pt]
a_{n1} & \cdots & \color{red}{a_{ni}} & \cdots & \color{red}{a_{ni}} & \cdots & a_{nn} \\
\end{array}
\!\right|
</tex>

　この第 2 項は$ i $列目と同じ内容が$ j $列目にも存在していることになり、0 である。
　よって第 1 項だけが残り、これは変形する前の行列と変わらない。
　つまり、「\red{ある列を定数倍して他の列に加えても行列式の値は変わらない}」ということになる。

<P>

　行列式について列で成り立つことは行でも成り立つので、
「\red{ある行を定数倍して他の行に加えても行列式の値は変わらない}」とも言えるわけだ。

<P>

　そう、なんと、何も変らないのだ！
　上三角行列を作るために、ある行を定数倍することは必要ではなかった。
　ただ場合によっては一番最初に行を入れ替える場合があったのだった。
　その時には符号が変化する。
　それ以外の操作では行列式は変化しないというのだ。



% =======================================================================

\section{まとめと次回予告}


　ああ、つまりそれは、なにかい？
　一次方程式の解を求めるために
行列の変形を繰り返すのはスマートじゃないと考えて代わりにクラメルの公式を使おうと思ったら、
行列の変形を繰り返すことで行列式の値を求めなきゃいけないということか。
　本末転倒じゃないか。
　しかも幾つもの行列式を計算する必要があるときている。
　結局のところ、実用上は行列の変形で解を求めるのが最も効率がいいというわけだ。

<P>

　じゃあ今回やったようなことは本当に理論を助けるための話に過ぎないわけだな。
　うん、まあいいや。
　それはそれで視野を広げるためには大切な事だ。
　いや・・・それが実は・・・それだけじゃない。
　ちゃんとこの後で役に立つ機会だってある。

<P>

　行列の使い道は連立方程式を解くだけではないのだ。
　次回は行列の別の使い道を紹介しよう。

<P>

　今回やった内容を最後に列挙してまとめようかと思っていたが、
赤字で書いたところを流して見ればいいだけなのでその必要もないだろう。


