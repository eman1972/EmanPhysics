\field{物理数学}
\title{超関数のフーリエ変換}
\comment{デルタ関数のフーリエ変換が<br>どういう前提で許されているか。}
\prev{fourier06}
\next{fourier08}
\create{2013/2/21}
\modify{}


\section{フーリエ変換が使える条件}

　フーリエ変換はフーリエ級数の周期を無限大に引き伸ばして作った概念だったから、
当てはめて使える関数も同じような性質のものだろうと考えたくなる。
　ところが少しだけ条件が違っているようなのだ。

<P>

　これが少し分かりにくい。
　ほとんどの理工系向けの教科書がこの部分を詳しく書いてくれていないからだ。
　手元の教科書では、「関数$ f(x) $が区分的に滑らかで、絶対可積分ならばフーリエ変換が成り立つ」とある。
　絶対可積分というのは関数の絶対値を取って積分したものが発散しないということであり、
次のように書かれる。

<tex>
\int^{\infty}_{-\infty} |f(x)| \diff x \ <\ \infty
</tex>

　教科書によっては「区分的に滑らか」という条件が書かれていないものもあるが、
敢えて書かなかっただけで本当は入れる必要があるのではないかと私は思う。
　この条件が入っていないと、理工系では決して扱う必要のないようなひねくれた関数が議論に上ってくるだろう。
　そのような関数についてもフーリエ変換が成り立つのかどうかの議論は簡単ではない気がする。

\note{　多くの教科書では以上のことがフーリエ変換が成り立つための十分条件であるように読み取れるのだが、
「絶対可積分は必要条件である」かのように書かれている資料も見つかったので私は混乱している。
これがどういうことなのか確かめたいのだが、何しろ、理工系向けの教科書ではこの辺りの証明が省略されているものばかりなのだ。
ひょっとすると「区分的に滑らか」という条件を入れない場合には必要条件になるのかも知れない、などと悩んでいる。}

　ところで、途中に無限大になる場所があっても積分値が有限であるような関数は普通にある。
　仮に区分的に滑らかで絶対可積分でありさえすればフーリエ変換が使えるというのなら、
関数の途中に無限大になるところが幾つかあっても問題ないということだろうか？
　だとしたらこれはフーリエ級数の場合とは大きな違いである。
　しかしそれについてもはっきり書かれている教科書は見つけ出せなかった。

\note{　なぜそのような点を気にしているかというと、途中で無限大になるような関数を許していいのなら、
デルタ関数をフーリエ変換することにも何ら問題がなさそうに思えてきてしまうからだ。
しかしデルタ関数をフーリエ変換することについては問題があると教科書にはっきり書かれており、
デルタ関数のような超関数をフーリエ変換することを正当化するための処方はしっかり紹介されていたりするのである。}

　今話したような疑問、すなわち、
絶対可積分であることとフーリエ変換可能であることの関係がどうなっているのかについては
実際の証明を見てみれば解決するのだろう。
　幾つかそれらしいことを論じている資料を見付けはしたのだが、読んでみても納得出来ないことばかりであり、
物理数学とは関係のない世界に分け入って来てしまった感がある。
　この辺りは私の宿題にしておこう。

<P>

　どんな関数なら使えるかという大体のイメージとしては、無限遠で急速に 0 になることである。
　たとえば$ f(x) = 1/x $という関数は$ x=0 $で問題が起きてしまうが、
そこを避けて積分したとしても、無限遠まで積分すると発散してしまう。
　それよりもずっと早く 0 に収束するような関数でないといけないだろう。
　途中で無限大になる点があるような関数を使っていいのかどうかはここでははっきりさせていないが、
そういうものは積分すると発散する可能性がぐんと高まるわけで、
計算してみてそうだったなら確実にアウトだとは言えるだろう。

% =======================================================================

\section{デルタ関数のフーリエ変換}

　デルタ関数は普通の意味での関数ではないのでフーリエ変換の公式に当てはめるわけには行かない。
　しかしデルタ関数の定義を使えば次のような計算は問題なく成り立つわけである。

<tex>
\int^{\infty}_{-\infty} \delta(x) e^{-ikx} \diff x \ =\ e^{0} \ =\ 1 \tag{1}
</tex>

　この見た目はデルタ関数のフーリエ変換をしたのと全く同じであり、
便宜上、「デルタ関数をフーリエ変換した結果は$ F(k) = 1 $である」と言ってしまっても良さそうだ。
　つまり、あらゆる波長の波が均等に混じり合ったものがデルタ関数であるというようなイメージである。

<P>

　しかしだからと言って「$ F(k) = 1 $を逆変換するとデルタ関数になる」と言ってしまうのは飛躍であろう。
　それに、$ F(k) = 1 $は絶対可積分な関数でもないから公式を当てはめるわけにも行かない。

<P>

　ではこのように考えたらどうだろう。
　フーリエ逆変換の式にフーリエ変換の式を代入したものは次のようになるのだった。
　（この形は前々回にも出てきた。）

<tex>
f(x) \ =\ \frac{1}{2\pi} \, \int^{\infty}_{-\infty} \left( \int^{\infty}_{-\infty} f(x') \, e^{-ikx'} \diff x' \right) \ e^{ikx} \diff k
</tex>

　この式の積分順序を交換して・・・、この操作には別に何の問題もないはずだ。

<tex>
f(x) \ =\ \int^{\infty}_{-\infty} f(x') \left( \frac{1}{2\pi} \int^{\infty}_{-\infty} e^{ik(x-x')} \diff k \right) \diff x'
</tex>

　これは良く見るとデルタ関数の定義と同じ形になっている。
　デルタ関数の定義は次のようにも書かれるのだった。

<tex>
f(x) \ =\ \int^{\infty}_{-\infty} f(x') \ \delta(x-x') \diff x'
</tex>

　上の二つの式を見比べると、要するに、次のような関係が成り立っていると結論できそうである。

<tex>
\delta(x) \ =\ \frac{1}{2\pi} \int^{\infty}_{-\infty} e^{ikx} \diff k \tag{2}
</tex>

　この式はあたかも、$ F(k) = 1 $をフーリエ逆変換しているかのような形をしているではないか。
　それでこの式のことを「\red{デルタ関数のフーリエ積分表示}」と呼ぶ。

<P>

　ところで (2) 式は指数関数の肩の符号を変えたとしても結果は変わらないので次のように表現されることもある。
　ほら、デルタ関数は偶関数でもあったことだし・・・。

<tex>
\delta(x) \ =\ \frac{1}{2\pi} \int^{\infty}_{-\infty} e^{-ikx} \diff k 
</tex>

　このように表されていても間違いではない。
　私が採用しているフーリエ変換の流儀では「 1 のフーリエ変換は$ 2\pi \, \delta(x) $になる」と表現できるだろう。
　別の流儀の教科書では「 1 のフーリエ変換はデルタ関数になる」と書かれていることがあるので、
そういう記憶に残りやすいフレーズに流されて勘違いをしてしまわないように敢えて書いておくことにした。

% =======================================================================

\section{超関数とは何か}

　このように、デルタ関数についてのフーリエ変換も逆変換も特に問題はなさそうだ。
　しかしデルタ関数というのは通常の関数の範疇には含まれない「超関数」なのだった。
　そのようなものを無邪気にフーリエ変換の公式に当てはめてみて、
問題なく式が成り立つことが示せたから受け入れて使ってしまおうという態度では節操がなさすぎると思うのだ。
　その辺りを理論的に整備しておく必要がある。

<P>

　そのためにはまず、「超関数」というのが何なのかを説明しておいた方がいい。
　数学的な厳密性はこれまで通り無視しよう。
　ざっと雰囲気を伝えたいだけである。

<P>

　何回でも微分できて、$ x \rightarrow \pm \infty $で素早く 0 に収束するような関数を$ \phi(x) $とする。
　そして次のような積分を考える。

<tex>
\int^{\infty}_{-\infty} f(x) \, \phi(x) \diff x
</tex>

　この積分が発散してしまわないで有限の値を持つ時、$ f(x) $のことを超関数だとするのである。
　あっけない話だろう？
　単純すぎて、普通の関数でさえ「超関数」に含まれてしまいそうだ。
　このように、超関数というのは普通の関数の多くもその中に含むような広い概念になっている。
　故に超関数と呼ばれているのである。

<P>

　超関数は英語では「distribution」と呼ばれており、「分布」という意味である。
　というのは、元々$ \phi(x) $であった関数を、

<tex>
\phi(x) \ \longrightarrow \ \int^{\infty}_{-\infty} f(x) \, \phi(x) \diff x
</tex>

のように有限の値へと対応させるような$ f(x) $を考えようというアイデアだからである。
　いかにも倍率の「分布」を設定して関数に重ね合わせることで、
それに応じた値を関数から取り出しているような感じではないか。

% =======================================================================

\section{超関数のフーリエ変換}

　今の説明によって、デルタ関数だけでなく、$ F(k) = 1 $という普通の関数も超関数の一種として考えられることが分かった。
　これらはどちらもフーリエ変換が可能な条件には当てはまっていないのだが、
なぜか形式上は問題なくフーリエ変換できているように見えるのだった。

<P>

　そこで、フーリエ変換の考えを少し押し広げて、
超関数に対してもフーリエ変換が使えるという根拠をはっきりさせておこう。

<P>

　先ほどの超関数の説明で、
「何回でも微分できて、$ x \rightarrow \pm \infty $で素早く 0 に収束するような関数」$ \phi(x) $というものを考えた。
　証明は省略するが、そのような関数をフーリエ変換したものも、同様な性質を持つらしい。
　ということは、$ f(x) $が超関数だとすると、次のような積分もまた発散しないで有限の値を持つわけだ。

<tex>
\int^{\infty}_{-\infty} f(x) \, \mathcal{F}[\phi](x) \diff x
</tex>

　これを変形してみよう。

<tex>
&=\ \int^{\infty}_{-\infty} f(x) \, \left[ \int^{\infty}_{-\infty} \phi(y)\,e^{-ixy} \diff y \right] \diff x \\
&=\ \int^{\infty}_{-\infty} \phi(y) \, \left[ \int^{\infty}_{-\infty} f(x)\,e^{-ixy} \diff x \right] \diff y \\
&=\ \int^{\infty}_{-\infty} \phi(y) \, \mathcal{F}[f](y) \diff y
</tex>

　計算のために仮の変数として$ y $を使ったが、記号の種類はどうでもいい。
　しかし雰囲気をつかみやすいようにいつもの変数に書き換えよう。

<tex>
=\ \int^{\infty}_{-\infty} \mathcal{F}[f] \ \phi(x) \diff x
</tex>

　この中の$ \mathcal{F}[f] $の部分が超関数$ f(x) $のフーリエ変換を意味している。
　超関数のフーリエ変換の定義がまだされていないのにこんな変形をしても良いのかと思うわけだが、
とりあえず該当部分を$ \mathcal{F}[f] $という記号で表してみたというだけの話である。
　肝心な最初と最後だけ抜き出して書き直そう。
　結論の方を左辺に持ってくることにする。

<tex>
\int^{\infty}_{-\infty} \mathcal{F}[f] \, \phi(x) \diff x \ =\ \int^{\infty}_{-\infty} f(x) \, \mathcal{F}[\phi](x) \diff x
</tex>

　さて、この式の左辺は超関数の定義を説明した時の式と同じ形式になっている。
　そして右辺は発散しないで有限の値を持つということもすでに言えている。
　ならば、この式が$ \mathcal{F}[f] $を定義する式として使えるのではないだろうか。

<P>

　同様な過程を繰り返すことにより、逆変換についても次のことが言える。

<tex>
\int^{\infty}_{-\infty} \mathcal{F}^{-1}[f] \, \phi(x) \diff x \ =\ \int^{\infty}_{-\infty} f(x) \, \mathcal{F}^{-1}[\phi](x) \diff x
</tex>

　それでこの式を超関数$ f(x) $のフーリエ逆変換$ \mathcal{F}^{-1}[f] $の定義式として採用しよう。


% =======================================================================

\section{具体例で試してみる}

　今導入した方法で本当にデルタ関数のフーリエ変換が定義できるのかを試してみよう。
　少し面倒な考え方が必要だと分かるはずだ。
　まず、次のように書けるだろう。

<tex>
\int^{\infty}_{-\infty} \mathcal{F}[\delta] \, \phi(x) \diff x \ =\ \int^{\infty}_{-\infty} \delta(x) \, \mathcal{F}[\phi](x) \diff x
</tex>

　この右辺はデルタ関数の性質により

<tex>
=\ \mathcal{F}[\phi](0)
</tex>

となる。
　フーリエ変換した結果の式の変数が 0 になるというのだから、具体的にはこうであるに違いない。

<tex>
=\ \int^{\infty}_{-\infty} \phi(x) \, e^{-i0x} \diff x
</tex>

すなわちこうである。

<tex>
=\ \int^{\infty}_{-\infty} \phi(x) \diff x
</tex>

　これを最初の左辺と比較すれば、$ \mathcal{F}[\delta] $が$ F(k) = 1 $と同じ機能を持っていることが分かる。

<P>

　続いて$ F(k) = 1 $のフーリエ逆変換もやってみせよう。
　今度も技巧的になるが、途中にいちいち解説を入れなくても何とか分かるだろう。

<tex>
\int^{\infty}_{-\infty} \mathcal{F}^{-1}[1] \, \phi(x) \diff x \ &=\ \int^{\infty}_{-\infty} 1 \, \mathcal{F}^{-1}[\phi](x) \diff x \\
&=\ \int^{\infty}_{-\infty} \mathcal{F}^{-1}[\phi](x) \, e^{-i0x} \diff x \\
&=\ \mathcal{F}[\mathcal{F}^{-1}[\phi]](0) \\
&=\ \phi(0)
</tex>

　要するにこれはデルタ関数の定義と同じ形であるので、1 の逆変換はデルタ関数だと結論できる。

<P>

　理屈的には最初の方でやったのとあまり変わりはない。
　しかしこうやって超関数のフーリエ変換を通常のフーリエ変換とは異なるものとして定義して、
特別に許されているものだということをはっきりさせておけば安心できるだろう。

% =======================================================================

\section{2乗可積分}

　超関数のフーリエ変換は、通常のフーリエ変換の性質をほとんど同じように満たすことが言える。
　しかしパーセバルの等式については微妙ではある。
　例えばデルタ関数の場合にパーセバルの等式を当てはめてみると

<tex>
\int_{-\infty}^{\infty} |\delta(x)|^2 \diff x \ =\ \frac{1}{2\pi} \, \int_{-\infty}^{\infty} 1 \diff x 
</tex>

となるわけだが、右辺は無限大に発散してしまうし、
左辺のようなデルタ関数の 2 乗を含む計算も定義されていないので計算不能だ。
　というわけで矛盾が起こるというほどの話でもないが、成り立つとも言えないわけだ。
　関数の内積がフーリエ変換の前後でどうなるかという公式もあったが、
これについては形式的には成り立っているようだ。
　しかし超関数で一般的に成り立つと言えるのかは不安である。

<P>

　関数の内積と言えば、こんな話があるのを思い出した。
　先ほどはフーリエ変換が可能であることの条件として絶対可積分というのが出てきたが、
これとは別の重要な条件として「\red{2 乗可積分}」というものがある。
　式で表すと次のようなものである。

<tex>
\int^{\infty}_{-\infty} |f(x)|^2 \diff x \ <\ \infty
</tex>

　関数はベクトルの一種であって、線形代数で議論できる対象であるという話を少し前から時々話してきた。
　そして関数がこの「2 乗可積分の条件」を満たしていれば、そのベクトル空間に問題なく内積が定義できるらしい。
　残念ながら、なぜそう言えるのかという納得の行く証明が書かれている書物を私はまだ見つけられないでいる。
　もう少し高度な数学書に手を出さないといけないのだろう。

\note{その数年後の現状報告：　上の式によって自分自身との内積が有限の値になることが保証されていることになるので、
それはノルムが問題なく定義されていることに他ならないということは分かった。
では「ノルムが定義されていればどんな組み合わせの内積も必ず有限になるか」と聞かれると、
「そんな気はするし、そう受け入れていたけどそう言えばじっくり考えたことはなかったな」という感じである。}

　デルタ関数の 2 乗の積分がどうなるかについては定義されていないそうなので、
この辺りのことを論じるのは慎重にならないといけないのだろうと考えている。

<P>

　「絶対可積分」と「2 乗可積分」とでどちらが厳しい条件であるかというのは言えない。
　「絶対可積分」だが「2 乗可積分」でない関数もあるし、「2 乗可積分」だが「絶対可積分」でない関数もある。
　おそらく、初歩的な物理や工学で出てくる関数を使っている限りではそのような問題は気にしなくても大丈夫なのだろう。

