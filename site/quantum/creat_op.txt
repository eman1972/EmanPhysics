\field{量子力学}
\title{生成演算子と消滅演算子}
\comment{交換関係こそが全て。<br>もちろん私の本心ではないが。}
\prev{boson_fermion}
\next{anticommute}
\create{2005/7/23}
\modify{}



\section{前置き}

　以前、粒子性を表すのに調和振動子の論理が応用できそうだという話をした。
　そのための準備として調和振動子についての理論構造をもっと詳しく調べておこう。
　これが「場の量子論」の基礎になる。

<P>
　積分記号を書くのは面倒なので、
ベクトル記法を中心に書き進めようと思う。
　もちろん、ここでの議論は全て波動関数を使って書き直すことも出来る。
　話の流れによっては |n&gt; を関数と呼んだりベクトルと呼んだりするが、
どちらも本質は同じだということを理解した上で許してもらいたい。


% =======================================================================

\section{またディラックなのか！}


　以前にやったのとは違う方法で調和振動子の問題を解いてやる。
　この方法を編み出して場の理論のきっかけを生んだのは、あの天才ディラックだ。

<P>

　時間に依存しないシュレーディンガー方程式をベクトルで書くと

<tex>
\hat{H} \ket{\psi} = E \ket{\psi}
</tex>

である。
　ただし、ハミルトニアン$ \hat{H} $は、

<tex>
\hat{H}\ =\ \frac{\hat{p}^2}{2m}\ +\ \frac{1}{2}m\ \omega^2 \hat{x}^2
</tex>

である。
　天才の動機というのは良く分からないのだが、
この形式を見て因数分解をしてやろうと閃いたわけだ。

<tex>
H\ &=\ \frac{1}{2}m\ \omega^2 \left( x^2\ +\ \frac{1}{m^2\omega^2}\ p^2 \right) \\
   &=\ \hbar \omega \frac{m\omega}{2\hbar} \left( x^2 + \frac{1}{m^2\omega^2}\ p^2 \right) \\
   &=\ \hbar \omega \frac{m\omega}{2\hbar} \left( x - \frac{i}{m\omega}p \right) \left( x + \frac{i}{m\omega}p \right)
</tex>


　係数の括り出し方に少し細工がしてあるが、理由はそのうちに分かる。
　ここで、

<tex>
\hat{a} \ &=\ \sqrt{ \frac{m\omega}{2\hbar} } \left( \hat{x} + \frac{i}{m\omega} \hat{p} \right) \\ 
\hat{a}^\dagger \ &=\ \sqrt{ \frac{m\omega}{2\hbar} } \left( \hat{x} - \frac{i}{m\omega} \hat{p} \right)
</tex>

という 2 通りの演算子を定義してやる。
　2 通りとは言っても、これらは互いにエルミート共役の関係にあるので、
一方を定義すればもう片方は自然に定義されるわけだ。
　この 2 つが単なる複素共役に見えてしまって、
なぜエルミート共役であるのかが分からないという人は、
次のような理解が欠けているかも知れない。
　普段あまり書かれないことではあるが、
$ x $や$ p $というのはエルミート演算子であって、

<tex>
\hat{x} \ =\ \hat{x}^\dagger  \ \ \ \ ,\ \ \ \ \hat{p} \ =\ \hat{p}^\dagger
</tex>

であることを思い出してもらえば合点が行くのではないだろうか。
　ついでに$ \hat{a} $や$ \hat{a}^\dagger $はエルミート演算子ではないことを注意しておこう。

<P>

　これらを使えばハミルトニアン$ \hat{H} $は

<tex>
\hat{H} \ =\ \hbar \omega\ \hat{a}^\dagger \hat{a}
</tex>

のようにシンプルに表せる・・・はずだった。
　いかにもそんなことが出来そうな気がするわけだが、そう甘くはない。
　演算子は掛ける順序によって計算結果が変わるのだった。
　その辺りに気をつけて、改めて$ \hat{a}^{\dagger} \hat{a} $を計算してやると、

<tex>
\hat{a}^\dagger \hat{a} \ &=\ \frac{m\omega}{2\hbar} \left( \hat{x} - \frac{i}{m\omega} \hat{p} \right) \left( \hat{x} + \frac{i}{m\omega} \hat{p} \right) \\
&=\ \frac{m\omega}{2\hbar} \left( \hat{x}^2 + \frac{i}{m\omega}\hat{x} \hat{p} - \frac{i}{m\omega}\hat{p} \hat{x} + \frac{1}{m^2\omega^2} \hat{p}^2 \right) \\
&=\ \frac{m\omega}{2\hbar} \left( \hat{x}^2 + \frac{1}{m^2\omega^2} \hat{p}^2 + \frac{i}{m\omega} [\hat{x}, \hat{p}] \right) \\
&=\ \frac{m\omega}{2\hbar} \left( \hat{x}^2 + \frac{1}{m^2\omega^2} \hat{p}^2 - \frac{\hbar}{m\omega} \right) \\
&=\ \frac{m\omega}{2\hbar} \left( \hat{x}^2 + \frac{1}{m^2\omega^2} \hat{p}^2 \right) - \frac{1}{2} 
</tex>

となる。
　だから$ \hat{H} $を$ \hat{a}^\dagger $や$ \hat{a} $で表したければ、

<tex>
\hbar \omega\ \hat{a}^\dagger \hat{a}\ 
&=\ \hbar \omega \left\{ \frac{m\omega}{2\hbar} \left( \hat{x}^2 + \frac{1}{m^2\omega^2} \hat{p}^2 \right) - \frac{1}{2} \right\} \\
&=\ \frac{m\omega^2}{2} \left( \hat{x}^2 + \frac{1}{m^2\omega^2} \hat{p}^2 \right) - \frac{1}{2} \hbar \omega \\
&=\ \left( \frac{m\omega^2}{2} \hat{x}^2 + \frac{1}{2m} \hat{p}^2 \right) - \frac{1}{2} \hbar \omega \\
&=\ \hat{H} - \frac{1}{2} \hbar \omega \\
\therefore\ \hat{H}\ &=\ \hbar \omega\ \left( \hat{a}^\dagger \hat{a} + \frac{1}{2} \right) 
</tex>

とするべきだったわけだ。
　何を期待してこんな事をしてきたのか分からないが、
式を単純化するという目的のためだけにやったのだとしたら、
何となく失敗に終わったようにも思える。
　・・・・。
　いや、その判断はまだ早い。

% =======================================================================

\section{交換関係}

　新しく導入した２つの演算子には面白い性質がある。
　交換関係を調べてやると、

<tex>
[\hat{a}, \hat{a}^\dagger ]\ =\ \hat{a} \hat{a}^\dagger - \hat{a}^\dagger \hat{a}\ =\ 1
</tex>

となる。
　結果がやたらときれいになるのは、
そうなるように$ \hat{a}^\dagger $と$ \hat{a} $の係数を調整したためだ。
　先ほど言っていた「細工」というのはこのことで、
これらの演算子が無次元量になるようにしておいたのだった。

<P>

　この関係を前提として次のようなことを考える。
　まず、

<tex>
\hat{N} \ =\ \hat{a}^\dagger \hat{a}
</tex>

を一つの演算子と見てやる。
　そして、

<tex>
\hat{N} \ket{n} \ =\ n \ket{n}
</tex>

となるような方程式を作る。
　演算子$ \hat{N} $を作用させると、
その固有値が$ n $として出てくるような関数$ \ket{n} $を探すわけだ。
　ところで、

<tex>
\hat{N}^\dagger \ =\ (\hat{a}^\dagger \hat{a})^\dagger \ =\ \hat{a}^\dagger (\hat{a}^\dagger)^\dagger \ =\ \hat{a}^\dagger \hat{a} \ =\ \hat{N}
</tex>

であるから、$ \hat{N} $は明らかにエルミート演算子だ。
　エルミート演算子の固有値は必ず実数になるのだった。
　つまり、$ n $は実数である。

<P>

　我々は以前に調和振動子の問題を解いたので、
勘のいい読者はここで$ n $という記号を使っている意味に気付いてしまったかも知れない。
　そういう人は、今は知らない振りをしていて欲しい。
　$ n $が 0 以上の整数でなければならないということも、
関数$ \ket{n} $が具体的にどんな形になるのかということも、
今の議論ではまるで知らなくていいのである。

<P>

　ところで関数$ \ket{n} $は規格化されているとする。
　つまり、

<tex>
\langle n| n \rangle \ =\ 1 
</tex>

である。
　しかも直交しているとする。
　つまり、

<tex>
\langle n| m \rangle \ =\ 0  \ \ \ \ ( n \neq m )
</tex>

である。
　これは、異なる固有値に属するベクトルは互いに直交する、という
線形代数のごく当たり前の要求である。


% =======================================================================

\section{&acirc; の働き}

　何だかすっかり調和振動子と関係ない話に向かっている気がするが、
意外な展開が待っているので楽しみにして欲しい。

<P>

　まず、$ \ket{n} $に$ \hat{a} $を作用させてから$ \hat{N} $を作用させよう。
　すると、

<tex>
\hat{N} \hat{a} \ket{n} \ &=\ (\hat{a}^\dagger \hat{a})\, \hat{a} \ket{n} \\
&=\ (\hat{a} \hat{a}^\dagger - 1)\, \hat{a} \ket{n} \\
&=\ (\hat{a} \hat{a}^\dagger \hat{a} - \hat{a}) \ket{n} \\
&=\ (\hat{a} \hat{N} - \hat{a}) \ket{n} \\
&=\ (\hat{a} n - \hat{a}) \ket{n} \\
&=\ (n - 1)\, \hat{a} \ket{n} \\ 
\therefore \ \hat{N} \hat{a} \ket{n} \ &=\ (n - 1)\, \hat{a} \ket{n}
</tex>

のようになる。
　これの意味するものが分かるだろうか。
　$ \hat{a} \ket{n} $というベクトルをひとかたまりのものとして見てもらいたい。
　これは$ \hat{N} $の固有ベクトルになっているのである。

<tex>
\hat{N} \bigg( \hat{a} \ket{n} \bigg) \ &=\ (n - 1)\, \bigg( \hat{a} \ket{n} \bigg)
</tex>

　しかも固有値は$ n-1 $だ。
　つまり$ \hat{a} \ket{n} $は$ \ket{n-1} $と似た性質を持っており、
ある定数倍だけ違うかも知れないが同じ方向を向いたベクトルであるということだ。

<tex>
\hat{a} \ket{n}\ =\ c\ \ket{n-1}
</tex>

　さて、ベクトル$ \ket{n-1} $も規格化されているという前提なので、そのことを元に$ c $の値を計算しておこう。

<tex>
\Big(\bra{n} \hat{a}^\dagger\Big)\Big(\hat{a} \ket{n}\Big) \ &=\ \Big(\bra{n-1} c^\ast\Big)\Big(c \ket{n-1}\Big) \\ 
\therefore\ \bra{n} \hat{N} \ket{n} \ &=\ |c|^2 \langle n-1 | n-1 \rangle \\ 
\therefore\ \bra{n} n \ket{n} \ &=\ |c|^2  \\ 
\therefore\ n \ &=\ |c|^2  \\ 
\therefore\ |c| \ &=\ \sqrt{n}
</tex>

　$ c $は規格化のための定数なので正の値を取っておけばいいだろう。
　つまり、

<tex>
\hat{a} \ket{n} \ =\ \sqrt{n}\ \ket{n-1}
</tex>

という関係があると言える。


% =======================================================================

\section{&acirc;<sup>&dagger;</sup> の働き}

　次に、$ \hat{a}^\dagger $についても同じ事を試そう。
　$ \ket{n} $に$ \hat{a}^\dagger $を作用させてから$ \hat{N} $を作用させる。

<tex>
\hat{N} \hat{a}^\dagger \ket{n} \ &=\ (\hat{a}^\dagger \hat{a})\, \hat{a}^\dagger \ket{n} \\
&=\ \hat{a}^\dagger ( \hat{a} \hat{a}^\dagger ) \ket{n} \\
&=\ \hat{a}^\dagger ( \hat{a}^\dagger \hat{a} + 1) \ket{n} \\
&=\ \hat{a}^\dagger ( n + 1) \ket{n} \\
&=\ ( n + 1)\, \hat{a}^\dagger \ket{n} \\
\therefore\ \hat{N} \hat{a}^\dagger \ket{n} \ &=\ (n + 1)\, \hat{a}^\dagger \ket{n}
</tex>

　これも同じような事になっている。
　$ \hat{a}^\dagger \ket{n} $をひとかたまりとして注目すると、
これは固有値が$ n+1 $の$ \hat{N} $の固有関数であり、
$ \ket{n+1} $と同じ方向を向いたベクトルになっている。

<tex>
\hat{a}^\dagger \ket{n} \ =\ c\ \ket{n+1}
</tex>

　同じように係数$ c $を計算しておこう。

<tex>
\Big(\bra{n} \hat{a}\Big)\Big(\hat{a}^\dagger \ket{n}\Big) \ &=\ \Big(\bra{n+1} c^\ast\Big)\Big(c \ket{n+1}\Big) \\ 
\therefore\ \bra{n} (\hat{a}^\dagger \hat{a} + 1) \ket{n} \ &=\ |c|^2 \langle n+1 | n+1 \rangle \\ 
\therefore\ (n+1) \langle n | n \rangle \ &=\ |c|^2  \\ 
\therefore\ \sqrt{n+1} \ &=\ |c| \\ 
\therefore\ |c| \ &=\ \sqrt{n+1}
</tex>

　よって、

<tex>
\hat{a}^\dagger \ket{n}\ =\ \sqrt{n+1}\ \ket{n+1}
</tex>

という関係があると言える。

% =======================================================================

\section{演算子の意味}

　つまり、$ \hat{a} $は固有関数$ \ket{n} $に作用して
固有値が 1 だけ小さな$ \ket{n-1} $に変化させる働きがあり、
$ \hat{a}^\dagger $には逆に、固有関数$ \ket{n} $に作用して
固有値が 1 だけ大きな$ \ket{n+1} $を作り出す働きがあるということだ。

<P>

　では$ \hat{a} $を何度も作用させる事でどこまでも固有値の小さな関数が
作り出せるかというと、そうでもない。

<tex>
n \ &=\ n \langle n | n \rangle \\
&=\ \bra{n} n \ket{n} \\
&=\ \bra{n} \hat{N} \ket{n} \\
&=\ \bra{n} \hat{a}^\dagger \hat{a} \ket{n} \\
&=\ || \hat{a} \ket{n} ||^2 \ \geqq \ 0 
</tex>

であり、$ n $は負であってはならないという制約があるからだ。
　上の式に出てくる$ ||\cdots|| $で囲まれた部分はベクトルの長さ「ノルム」を表している。
　ベクトル$ \hat{a} \ket{n} $のエルミート共役は$ \bra{n} \hat{a}^\dagger $であって、 
上では同じベクトル同士の内積を計算したことになる。
　それが正の値になるというのは以前に
「<a href="./bracket.html#naiseki">複素関数の内積</a>」のところでも説明した通りだ。

<P>

　これで$ n $は 0 以上でなければならないということが分かった。
　しかし$ n $として正の値を使っていたとしても、1 ずつ下げて行くと、
やがていつかは$ 0 \leqq n \le 1 $というところにまで辿り着くだろう。
　そこへさらに$ \hat{a} $を作用させれば$ n $が負だという
許されていない状態が生み出されてしまう。
　これは問題だ。

<P>

　ただ、$ n $が整数である場合に限っては、このような問題は回避できる。
　$ n $を 1 ずつ減らして行くことでやがては$ \ket{0} $という状態にまでたどり着くことになり、
そこへ$ \hat{a} $を作用させればやはり同じ問題に突き当たる気がする。
　ところが、上の式の最後の等号より、
$ \hat{a} \ket{n} = 0 $となる場合があることが分かるだろう。
　さらに同じ式の初めの等号に目を向ければ、それは$ n = 0 $の時である事も同時に分かる。
　つまり、

<tex>
\hat{a}\ \ket{0} \ =\ 0
</tex>

という関係が成り立っているということだ。
　一度 0 ベクトルとなったものに幾ら繰り返し$ \hat{a} $を作用させても
 0 のままなので、固有値が負として出てくるような問題も起こり得ない。


% =======================================================================

\section{演算子法}


　こうして$ n $は「非負の整数」に制限しておくべきだという結論を得た。
　この論法に納得できないという人は、
この他にも色々な説明の仕方があるので、
もっと巧妙で厳密な方法を探してあれこれ調べてみるといいだろう。

<P>

　以上のことを使えば、今回の一番初めに書いた方程式は

<tex>
\hbar \omega \left( \hat{N} + \frac{1}{2} \right) \ket{\psi} \ =\ E \ket{\psi} 
</tex>

と書き直せるが、$ \ket{\psi} $は代わりに$ \ket{n} $としても成り立ち、その時のエネルギー固有値$ E $は、

<tex>
E \ =\ \hbar \omega \left( n + \frac{1}{2} \right)
</tex>

であるということが言える。
　以前に「<a href="./oscillator.html">調和振動子</a>」という記事の中で
調和振動子の方程式を一生懸命に解いたことがあるが、それと同じ結果がこうして導かれるのである。

<P>

　ここで満足して説明を終えてしまうと、
今回の方法では関数$ \ket{n} $の具体的な形を求めるところまでは出来ないのか、
と誤解されてしまう心配があるので、ちゃんと最後までやっておくことにしよう。
　以前の結果と比較しやすいように、
$ \hat{a}^\dagger $と$ \hat{a} $を具体的な座標表示の微分演算子の形で表し、
前と同じスケール変換

<tex>
x \ =\ \sqrt{\frac{\hbar}{m \omega}}\ \xi
</tex>

を使って$ x $を$ \xi $に書き換えてやれば、

<tex>
\hat{a} \ &=\ \frac{1}{\sqrt{2}} \left( \xi + \pdif{}{\xi} \right) \\
\hat{a}^\dagger \ &=\ \frac{1}{\sqrt{2}} \left( \xi - \pdif{}{\xi} \right)
</tex>

というすっきりした形式を得る。
　ここで、

<tex>
\hat{a}\ \ket{0} \ =\ 0
</tex>

という式より、

<tex>
\left(\xi + \pdif{}{\xi}\right) \phi\sub{0}(\xi)\ =\ 0
</tex>

という微分方程式が作られ、これを解けば、

<tex>
\phi\sub{0}(\xi)\ =\ A\ e^{-\frac{\xi^2}{2}}
</tex>

という、以前と同じ結果が得られる。
　$ n $が 1 以上の場合の波動関数を知りたければ、今の結果に$ \hat{a}^\dagger $を次々と作用させればいい。

<P>

　$ \hat{a}^\dagger $を作用させるたびに$ \sqrt{n+1} $という係数が出てくる。
　初めは$ \ket{0} $に作用して 1 だが、その次には$ \sqrt{2} $、次は$ \sqrt{3} $と増えていき、
$ n $回作用させるとそれらを全部を掛け合わせたもの、すなわち$ \sqrt{n\,!} $を掛けたことになる。

<tex>
(\hat{a}^\dagger)^{n} \phi\sub{0}\ =\ \sqrt{n!}\ \phi_n
</tex>

　よって、

<tex>
\phi_n\ &=\ \frac{1}{\sqrt{n!}} \big(\hat{a}^\dagger \big)^n \phi\sub{0} \\
        &=\ A \frac{1}{\sqrt{n!}} \frac{1}{\sqrt{2^n}} \left( \xi - \pdif{}{\xi} \right)^n e^{-\frac{\xi^2}{2}}
</tex>

　この時に掛けた係数は規格化を考慮したものであるので、
初めに$ \phi\sub{0} $を規格化して$ A $の値を決めておきさえすれば、
後は$ n $が幾つの時にだって規格化がすでに出来た状態になっている。
　便利なものだ。

<P>

　今回の方法は「演算子法」として、
微分方程式の解法の教科書にも載っている方法である。
　学生の時に数学の先生が
「この解き方は物理学者が見つけたもので、
理由は良く分からないがなぜか解けるのだ」と説明していたのが印象的だった。
　当時はディラックの事も、調和振動子のことも、
なぜその形の方程式を解く必要があるのかも分かっていなかったから、
その言葉だけが頭に残った。
　演算子法そのものはディラック以前、19 世紀末にはあったので、
その先生の言っていた物理学者とはヘビサイドのことかも知れない。


% =======================================================================

\section{n を粒の数と見る}

　$ n $は$ h\nu $というエネルギーかたまりの数だとする見方は、前に調和振動子の話をしたときに説明した。
　今回の演算子の導入は、その見方を推し進めるのに好都合だ。

<P>

　つまり、演算子$ \hat{N} $というのは、その状態の中に
幾つのエネルギーの粒が存在するのかを固有値として取り出す働きがあるという解釈が可能なわけだ。
　それで、この演算子を「\red{粒子数演算子}」と呼ぶ。
　英語に忠実に「数演算子」と呼ぶ教科書も多いが、響きが今ひとつ好きになれない。
　「\red{個数演算子}」ならまだ許せる。
　（全く個人的な好みの話で申し訳ない。）

<P>

　今や粒子数も、運動量や座標のように、
あたかも一つの物理的観測値であるかのような扱いだ。
　前に「無限次元の複素ベクトル空間」内にあるベクトルから
運動量や座標を取り出す「運動量表示」や「座標表示」を学んだが、
この空間内の別の方向からこの同じベクトルを見れば、
粒子数の情報も取り出す事が可能だということである。
　$ n = 0 $を表す軸や、$ n=1 $を表す軸などが無数にあって、
その各成分の和で状態を表示できるというわけだ。
　「\red{粒子数表示}」とでも呼ぼうか。

<P>

　$ \hat{a}^\dagger $はある状態に作用して、
粒子の一つ多い別の状態に変化させたとして解釈できる。
　それで、$ \hat{a}^\dagger $を粒子を新しく生み出したという意味を込めて「\red{生成演算子}」と呼ぶ。
　逆に$ \hat{a} $を「\red{消滅演算子}」と呼ぶ。
　こうして我々は粒子の増減を表すための数学的な道具を得た事になる。
　具体的にどう活用するかはしばらく後でじっくり考えることにしよう。

<P>

　しかし忘れてはいけないことがある。
　これは調和振動子だからこういう事が出来たのだということだ。
　そして粒子数と言っても、
まだ 1 粒子が持っている離散的なエネルギーの数を数えて、
粒のように扱っているというだけである。

<P>

　もっと別の形のポテンシャルの中でも使える理論にするためには、
まだ幾つかの工夫が必要なのである。
　そしてやがては、本当の粒子の数の増減を扱えるようにもしたい。

% =======================================================================

\section{本質はどこにあるか}

　さて、今回の論理の主役を演じたのは何だっただろう。
　関数$ \ket{n} $の具体的な形は最後のおまけに過ぎなかった。
　ハミルトニアン$ \hat{H} $も、調和振動子のポテンシャルも、きっかけを与えたに過ぎない。

<P>

　2 つの生成・消滅演算子の交換関係を導入した後は、
これらの具体的な定義はもはや関係なかった。
　ほとんどそれだけで話が進み、後は何も要らなかった。
　この交換関係こそが本質だという人がいる。

<P>

　そういう抽象的な考え方が気に入らないとしても、
いずれ別の交換関係を元にして別の論理を組み立てなくてはならないときが来る。
　今だって、2 つの演算子の定義を見たところで正直わけが分からないだろう。
　ただその働きの結果で物理的意味を知るのみだ。


