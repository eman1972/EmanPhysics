\field{量子力学}
\title{ブラケット記法}
\comment{世界はよくもまぁ、<br>こんなくだらないシャレに付き合わされたものだ。}
\prev{orthogonal}
\next{unitary}
\create{2003/6/9}
\modify{}


\section{波動関数はベクトルだ}


　前回は「完全規格直交系」について学んだ。
　今回はこれを波動関数に応用してやる話だ。

<P>

　範囲の制限はあるものの、
あらゆる形の関数が完全規格直交系の係数の組で表されるというので、
同じように波動関数もベクトル表現してやろうではないか。

<P>

　ただ前回と少し事情が違うのは、
波動関数というのは位置や時間の変数に対して複素数を返す関数であるという点である。
　しかしこれは全く問題がない。
　前回の説明に出てきた係数$ a\sub{0}, a\sub{1}, a\sub{2}, \cdots $が複素数になっていると
考えてやればいいのである。
　これだけで分かる人はいいのだが、
中には納得したつもりになっているだけの人もいるだろうから
ちゃんと詳しく説明しておくことにしよう。

<P>

　波動関数を実数部分と虚数部分に分けて考えることにする。

<tex>
\psi(x) \ =\ g(x)\ +\ i\ h(x)
</tex>

　それぞれの部分は前回やったようにベクトルで表されるだろう。

<tex>
g(x)\ &\rightarrow\ (\ j\sub{0},\ j\sub{1},\ j\sub{2},\ \cdots ,\ j_n,\ \cdots\ ) \\
h(x)\ &\rightarrow\ (\ k\sub{0},\ k\sub{1},\ k\sub{2},\ \cdots ,\ k_n,\ \cdots\ ) 
</tex>

　そしてそれを後で一緒にしてやればいいわけだ。

<tex>
a_n\ =\ j_n \ +\ i\ k_n
</tex>

　これで疑う余地がなくなっただろう。

<P>

　つまり\red{波動関数は無限次元の複素数ベクトルとして表現できる}ということだ。

<P>

　これをこの後に出てくる計算の都合上、縦一列のベクトルとして表してやったものを
「\red{ケット・ベクトル}」と呼び、$ |\psi\rangle $という記号で表す。

<tex>
|\psi\rangle \ =\ \left( \begin{array}{c} a\sub{0} \\ a_1 \\ a\sub{2} \\ \vdots \\ a_n \\ \vdots \end{array} \right)
</tex>

　$ |\psi\rangle $という記号の形がいかにも意味ありげだが、今はまだ気にしなくていい。
　速度ベクトル$ ( v_x, v_y, v_z ) $を象徴的に$ \Vec{v} $という記号で表すのと全く同じことである。
　なぜ「ケット・ベクトル」などというけったいな名前で呼ばれているかについては後で説明する。

<P>

　とにかくこいつは波動関数が姿を変えたものであって、
量子力学的な状態を漠然と表す抽象的なベクトルである。
　これを「\red{状態ベクトル}」と呼ぶこともあるが、
量子力学における状態の全ては波動関数に表れているのだ、という思想が読み取れよう。


% =======================================================================

\section{ブラ・ベクトル}

　以前に波動関数を使って粒子の存在確率を求めることをした。
　その時の式が、

<tex>
\int \psi^{\ast}(x)\, \psi(x)\ \diff x \tag{1}
</tex>

というものであり、$ -\infty \leqq x \leqq \infty $の範囲で積分した結果は 1 にならなければ
ならないのであった。
　しかし前回断ったように今は束縛状態の粒子に限定して考えているのであり、
その場合にはある範囲の外側では波動関数の値は 0 である。
　よって、その内側だけで積分した結果が 1 になればいいのである。

<P>

　この (1) 式に使われている波動関数$ \psi(x) $を、
完全規格直交系を成している関数群を使って展開した形に直してから、
この (1) 式の積分を計算してやると、どんなことになるだろうか。
　まず、

<tex>
\psi(x) \ =\ a\sub{0}\phi\sub{0}(x) + a\sub{1}\phi\sub{1}(x) + a\sub{2}\phi\sub{2}(x) + \cdots
</tex>

であり、それの複素共役を取った$ \psi^{\ast} $は、
それぞれの係数の複素共役を取ってやれば実現できるので、次のようになる。

<tex>
\psi^{\ast}(x) \ =\ a^{\ast}\sub{0}\phi\sub{0}(x) + a^{\ast}\sub{1}\phi\sub{1}(x) + a^{\ast}\sub{2}\phi\sub{2}(x) + \cdots
</tex>

　正式には係数だけでなく直交系関数群$ \{ \phi_{n} \} $の方も複素共役を取ってやるべきだが、
今のところはこれらは実数関数であると考えているのでこれでいいとしておこう。

<P>

　そして、これらの式を (1) 式に代入してやって、完全性の成り立つ範囲で積分してやるわけだ。
　積分の中には膨大な組み合わせの積が出来るが、
そのほとんどは関数の直交性によって消えてしまうだろう。
　それで結局は、

<tex>
a\sub{0}^{\ast}a\sub{0} + a\sub{1}^{\ast}a\sub{1} + a\sub{2}^{\ast}a\sub{2} + \cdots \tag{2}
</tex>

という答えが残るのみである。

<P>

　さあ！
　我々はこれと全く同じ結果をもっと簡単に得る方法を知っている！
　よな？
　行列計算の出番だ。

<P>

　先ほど、縦一列のベクトルをケットベクトルと呼んだが、
その中身を全て複素共役の値に置き換えてやり、
横一列に並べ替えたものを考える。

<tex>
\left( \begin{array}{cccccc}  a\sub{0}^{\ast} & a\sub{1}^{\ast} & a\sub{2}^{\ast} & \ldots & a_n^{\ast} & \ldots \end{array} \right)
</tex>

　こいつをケット・ベクトルの左側から掛けてやるのだ。
　行列計算の規則は知っているよな？

<tex>
\left( \begin{array}{cccccc}  a\sub{0}^{\ast} & a\sub{1}^{\ast} & a\sub{2}^{\ast} & \ldots & a_n^{\ast} & \ldots \end{array} \right)
\left( \begin{array}{c} a\sub{0} \\ a\sub{1} \\ a\sub{2} \\ \vdots \\ a_n \\ \vdots \end{array} \right)
</tex>

　これで (2) 式と同じ結果が得られるのである。

<P>

　ここで新しく出てきた横一列の行列を「\red{ブラ・ベクトル}」と呼び、$ \langle \psi| $という記号で表す。

<tex>
\langle \psi| \ =\ \left( \begin{array}{cccccc}  a\sub{0}^{\ast} & a\sub{1}^{\ast} & a\sub{2}^{\ast} & \ldots & a_n^{\ast} & \ldots \end{array} \right)
</tex>

　ケットベクトルの複素共役を取って、転置行列にしたものがブラベクトルだというわけだ。
　複素共役を取って転置行列に変換する記号を「$ \dagger $」と書き、「\red{ダガー}（短剣の意）」と呼ぶが、
この記号を使えば、今言ったことは

<tex>
| \psi \rangle ^{\dagger} \ =\ \langle \psi |
</tex>

と表せる。
　この二つのベクトルの関係を「随伴」あるいは「\red{エルミート共役}」と呼ぶ。
　さっきから「複素共役を取って転置行列にする」といちいち言うのがとても面倒だが、
代わりに「随伴行列を作る」とか「エルミート共役をとる」とかいう表現が使えるわけだ。
　これからはこのような用語を使わせてもらうことにしよう。

<a id="naiseki"></a>
% =======================================================================

\section{複素関数の内積}

　ここまでで、ブラベクトルを左に、ケットベクトルを右にして掛け合わせたものは
関数の内積を計算したのと同じ結果を与えるということが分かった。

<P>

　ああ、しまった！
　まだ関数の内積を正確には説明していなかった。
　前回の話の中で関数の内積が出てきたが、あれは実数の関数の場合の定義なのである。
　量子力学の波動関数のように複素数を返す関数の場合には
一方を複素共役にして掛け合わせてから積分をしなければならない。
　分かりやすいように具体的な例で説明しよう。
　ある複素関数$ f(x) $と$ g(x) $との内積は次のようにするのである。

<tex>
\int f^{\ast}(x)\, g(x) \diff x \tag{3}
</tex>

　実数の場合には複素共役をとっても何にも変化がないわけで、
つまり、この計算は前回やった実数関数の内積の、複素関数への拡張版になっているのである。

<P>

　これと同じことをブラとケットを使って表せば、

<tex>
\langle f|g \rangle \tag{4}
</tex>

と書けるわけだ。
　(3) 式と (4) 式とは等式で結んでやって構わない関係にある。

<P>

　ここで読者はなぜ左側に置かれた関数ばかり複素共役をとるのだ？と疑問を持つかも知れない。
　もし逆に右側に置かれた関数の複素共役をとるようにすれば、内積の値が違ってしまうのではないだろうか。
　実は複素関数の内積にはそういう性質があるのだ。
　ブラとケットで書けば、

<tex>
\langle f|g \rangle \ =\ \langle g|f \rangle ^{\ast}
</tex>

ということである。
　ここでブラとケットを使ったのはその方がすっきりと書けるからというだけの理由であって、
もちろん積分記号を使っても同じことが表せる。
　このことはここまでの話を理解していれば分かるだろう。

<P>

　内積の値が関数の順序によって変わるというこの性質は受け入れるしかない。
　もともとなぜ片方の関数だけ複素共役を取るかと言えば、
同じ関数どうしの内積の値が正の値になるように仕方なくそういう措置を取ったのである。

<tex>
\langle f|f \rangle \geqq 0
</tex>

　粒子の存在確率の計算は、
偶然なのか波動関数の内積を取るのと数学的に同じ意味であるわけだ。



% =======================================================================

\section{今更だが名前の由来}

　ブラとケット。
　二つ合わせて「ブラケット（かっこの意）」。

<P>

　括弧が閉じればベクトルではなくスカラーの複素数値になる。
　よく出来た分かりやすい表現法だ。
　この書き方を発明したのはあの奇才ディラックである。
　アイデアさえ良ければつまらないシャレも
ユーモアとしてついでに受け入れられるというものだ。

<P>

　勘違いしてはいけない。
　もともとの理論を考え出したのは若きハイゼンベルクである。
　その理論が行列を使えばすっきりとまとめ上げられることに気付き、
努力して書き直したのがその師ボルンである。
　そしてそれをディラックが「ええとこ取り」したわけだ。

