\field{量子力学}
\title{2入力量子ゲート}
\comment{これでちょっと不思議な状態が作り出せる。}
\prev{computer3}
\next{computer5}
\create{2018/6/17 14:40}
\modify{}

\section{制御ユニタリゲート}

　今回は 2 入力 2 出力の量子ゲートの話である。
　これは「\red{制御ユニタリゲート}」という名前で一括りにしてしまえる。

\image{./computer4/c_unitary.png,制御ユニタリゲートの図記号}

　入力のうちの一方は「\red{制御ビット（コントロールビット）}」と呼ばれており、何の変化も受けずにそのままの状態で出力される。
　もう一方の入力は「\red{標的ビット（ターゲットビット）}」と呼ばれており、
制御ビットの内容によって行われる操作が違ってくる。
　とは言っても非常に単純な話であって、もし制御ビットが$ \ket{0} $なら標的ビットの方も何の加工も受けずにそのまま出てくるが、
もし制御ビットが$ \ket{1} $ならゲートごとにあらかじめ定められたユニタリ変換$ \hat{U} $が施された状態で出てくる、
というそれだけである。

<P>

　もし制御ビットが$ \ket{0} $と$ \ket{1} $の重ね合わせだったなら、
標的ビットは、加工を受けなかった場合と受けた場合との重ね合わせになるのだが、
実はそんな簡単な説明で終わらせていいほど単純ではない。
　ちょっと予想外だと思うようなことが起きているのである。

<P>

　それを説明するにはもう少し簡単なところから始めた方がいいだろう。
　制御ユニタリゲートの中でもかなり単純で、しかも良く使われるものがある。
　「\red{制御NOTゲート}」あるいは「\red{CNOTゲート}」と呼ばれるものである。
　CNOT というのは Controlled-NOT という意味である。

% =======================================================================

\section{CNOTゲート}

　CNOTゲートというのは制御ビットが$ \ket{0} $なら何もしないが、
制御ビットが$ \ket{1} $なら標的ビットの$ \ket{0} $と$ \ket{1} $とを反転させるという機能を持つゲートである。
　反転というのは、標的ビットがもし$ \ket{0} $なら$ \ket{1} $になって出ていくし、
もし$ \ket{1} $なら$ \ket{0} $になって出ていくということで、古典的なNOTゲートに似ている。

<P>

　もう少し一般的な表現をしておこう。
　標的ビットが次のような状態だったとする。

<tex>
\ket{\psi} \ =\ a \, \ket{0} \ +\ b \, \ket{1} 
</tex>

　もし制御ビットが$ \ket{1} $ならば、この状態は反転されて次のような状態になって出ていく。

<tex>
\ket{\psi'} \ =\ a \, \ket{1} \ +\ b \, \ket{0} 
</tex>

　実はこの反転というのは前回の話で出て来た「Xゲート」と同じ働きである。
　前回は言い忘れたが「Xゲート」は「NOTゲート」と呼ばれることもある。

\image{./computer4/cnot.png,CNOTゲートの図記号}

　この図記号の意味だが、古典的な論理での排他的論理和を計算するときに使われている$ \oplus $という記号が由来である。
　二つの入力がともに$ \ket{0} $のとき、ともに$ \ket{1} $のときに標的ビットの出力が$ \ket{0} $になり、
一方が$ \ket{0} $で他方が$ \ket{1} $のときに標的ビットの出力が$ \ket{1} $になる様子が
まるで XOR ゲート（排他的論理和ゲート）の動作を思い出させるからである。
　たまに見かけることがある他の書き方は「制御Xゲート」であることを意味しているのだろう。

<P>

　さて、細かい話はこれくらいにして、本題をさっさと話すとしよう。
　制御ビットが$ \frac{1}{\sqrt{2}}( \ket{0} + \ket{1} ) $で、標的ビットが$ \ket{0} $だったとする。
　つまり、半々の確率で標的ビットは$ \ket{0} $のままか$ \ket{1} $に変わることになるだろう。
　するとそれは結局のところ、標的ビットは$ \frac{1}{\sqrt{2}}( \ket{0} + \ket{1} ) $と表せる状態になっていそうである。
　ところがそうではないのだ。
　\red{もはやこの制御ビットと標的ビットはそれぞれ単独では表せない状態になっているのである。}

<P>

　このゲートを抜けてきた制御ビットを観測すると半々の確率で 1 か 0 が出るのだが、
もし 1 が出たら、標的ビットを観測した時も必ず 1 が出る。
　もし 0 が出たら、標的ビットも必ず 0 として観測されるのである。
　要するに、「制御ビットが$ \ket{0} $だったので標的ビットがそのまま$ \ket{0} $として出て来た世界」と
「制御ビットが$ \ket{1} $だったので標的ビットが反転して$ \ket{1} $になった世界」との重ね合わせになるわけだ。
　\red{我々としてはそのどちらかの世界の一方を観測することになる。}

<P>

　制御ビットと標的ビットが
それぞれどちらも$ \frac{1}{\sqrt{2}}( \ket{0} + \ket{1} ) $となって出てきているならこんな観測結果にはならない。
　どちらも 0 と 1 が半々の確率で出るのだから、観測結果としてはあらゆる組み合わせがありうるはずだが、そうはならないのである。
　だから、この不思議な状態を表すためには何かもっと別の表現を使う必要がある。
　制御ビットの状態$ \ket{\psi_c} $と標的ビットの状態$ \ket{\psi_t} $を並べて組にしたものを一つの状態$ \ket{\Psi} $とみなすことをしてみよう。

<tex>
\ket{\Psi} \ =\ \ket{\psi_c} \ket{\psi_t}
</tex>

　もしそれぞれの状態が

<tex>
\ket{\psi_c} \ &=\ a \, \ket{0} \ +\ b \, \ket{1} \\[3pt]
\ket{\psi_t} \ &=\ c \, \ket{0} \ +\ d \, \ket{1} 
</tex>

となっていたら、

<tex>
\ket{\Psi} \ &=\ \ket{\psi_c} \ket{\psi_t} \\[3pt]
&=\ \Big( a \, \ket{0} \ +\ b \, \ket{1} \Big) \, \Big( c \, \ket{0} \ +\ d \, \ket{1} \Big) \\[3pt]
&=\ ac \, \ket{0}\ket{0} \ +\ ad \, \ket{0}\ket{1} \ +\ bc \, \ket{1}\ket{0} \ +\ bd \, \ket{1}\ket{1} \tag{1}
</tex>

のように表せるだろう。
　これは$ \ket{0}\ket{0} $と$ \ket{0}\ket{1} $と$ \ket{1}\ket{0} $と$ \ket{1}\ket{1} $の 4 つの状態の
重ね合わせになっている。
　ところが今回の場合には

<tex>
\ket{\Psi} \ =\ \frac{1}{\sqrt{2}} \Big( \ket{0}\ket{0} \ +\ \ket{1}\ket{1} \Big) \tag{2}
</tex>

という特殊な状態が出来上がったと言えるのである。
　何が特殊かと言えば、この状態は$ \ket{\psi_c} $と$ \ket{\psi_t} $の積という形では表せないというところだ。
　(1) 式と(2) 式とを両立させる$ a, b, c, d $の組がないことを確かめてみればいい。
　つまり、$ \ket{\psi_c} $と$ \ket{\psi_t} $の二つの状態は分けて考えることができず、
一つの状態$ \ket{\Psi} $を共有しているのである。
　このような状態を「\red{エンタングル状態}」と呼ぶ。

<P>

　最初に「制御ビットの状態$ \ket{\psi_c} $は何も変化を受けずに出てくる」と書いたが、
どうやら訂正しなければならないようだ。
　$ \ket{\psi_c} $と$ \ket{\psi_t} $の状態をそれぞれ独立して記述することができなくなる場合があり得るらしい。
　つまり、$ \ket{\psi_c} $だけを取り出してくることがそもそも無理で、
そんなときには「入力と同じままだ」などと言うことが出来ない。
　そんな場合もあり得るのではないだろうか。


% =======================================================================

\section{数式的理解}

　この少し奇妙な制御ユニタリゲートの機能を行列あるいは演算子の形で表してみたい。
　そうすればどんな入力に対してどんな出力があるのかを計算によって統一的に検証できて、
全体像を把握しやすいのではなかろうか。
　先ほどのCNOTゲートの話ではたまたまエンタングル状態になる例を選んでしまったのかもしれないし、
入力パラメータを様々に変えると何が起こるかをちゃんと知っておきたい。

<P>

　最初の説明では独立した制御ビットと標的ビットがそれぞれ入力されるかのように話したのだが、
どうやら両方を合わせて一つの状態となったものである$ \ket{\Psi} $が入力されて、
それが加工されて出ていくというイメージを持っていた方がいいのかもしれない。
　一つの制御ユニタリゲートから出てくる 2 本の出力がエンタングル状態になって出てきて、
その 2 本がそのまま別の制御ユニタリゲートの入力になる場合もあるだろうからだ。

<P>

　既に話したように、二つの量子ビットを一組にした状態というのは、
$ \ket{0}\ket{0} $と$ \ket{0}\ket{1} $と$ \ket{1}\ket{0} $と$ \ket{1}\ket{1} $の 4 つの状態の重ね合わせになっている。

<tex>
\ket{\Psi} \ =\ \alpha \, \ket{0}\ket{0} \ +\ \beta \, \ket{0}\ket{1} \ +\ \gamma \, \ket{1}\ket{0} \ +\ \delta \, \ket{1}\ket{1} \tag{3}
</tex>

　ただしこの係数は次の条件を満たしている。

<tex>
|\alpha|^2 \ +\ |\beta|^2 \ +\ |\gamma|^2 \ +\ |\delta|^2 \ \ =\ 1
</tex>

　(1) 式のようにして$ \ket{\Psi} $を作った場合にはこの条件が自動的に満たされるようになっている。
　難しくはないので、もし暇なら確認してみてほしい。

<P>

　この (3) 式の$ \ket{\Psi} $は$ \ket{\psi_c} $と$ \ket{\psi_t} $の積として表すことが出来る場合もあればそうでない場合もある。
　それでも二つ並んだベクトルの前の方は制御ビットの状態で、後の方は標的ビットの状態である。
　制御ユニタリゲートの作用は、この状態$ \ket{\Psi} $に対して働く次のような演算子として表現すればよい。

<tex>
\hat{C} \ =\ \ket{0}\bra{0} \, \hat{I} \ +\ \ket{1}\bra{1} \, \hat{U}
</tex>

　この$ \ket{0}\bra{0} $や$ \ket{1}\bra{1} $の部分は制御ビットの方にだけ作用する演算子であり、
$ \hat{I} $や$ \hat{U} $は標的ビットの状態だけに作用する演算子だと決めておこう。
　$ \hat{I} $というのは恒等演算子、つまり何も変化させない演算子で、単位行列のようなものである。

<P>

　$ \bra{0} $や$ \bra{1} $というのはこの量子コンピュータの記事では初めて出てくるものだから
簡単に説明しておく必要があるかもしれない。
　$ \bra{0} $はベクトル$ \ket{0} $を転置して複素共役を取ったものである。
　$ \ket{0} $が縦ベクトルだったから$ \bra{0} $は横ベクトルであり、
$ \ket{0} $の成分は簡単に実数に選んでおいたから複素共役を取っても変化がない。
　$ \bra{1} $も同じようなものである。
　だから具体的には次のようなものであると考えてもらっていい。

<tex>
\bra{0} \ &=\ \big( \ 1 \ \ 0 \ \big) \\
\bra{1} \ &=\ \big( \ 0 \ \ 1 \ \big) 
</tex>

　これらには次のような関係がある。

<tex>
\langle 0 | 0 \rangle \ &=\ 1 \\
\langle 0 | 1 \rangle \ &=\ 0 \\
\langle 1 | 0 \rangle \ &=\ 0 \\
\langle 1 | 1 \rangle \ &=\ 1 
</tex>

　これは普通に行列の計算をすれば確かにそうなっていると確認ができる。
　なるほど、$ \ket{0}\bra{0} $の右に$ \ket{0} $が来ると$ \ket{0}\langle 0 \ket{0} = \ket{0} $となって
$ \ket{0} $だけが残るし、
右に$ \ket{1} $が来ると$ \ket{0}\langle 0 \ket{1} = 0 $になって項ごと消えてしまう仕組みなわけだ。
　$ \ket{1}\bra{1} $についても同様で、右に$ \ket{1} $が来たときだけ項が生き残って、
標的ビットに対して$ \hat{U} $が実行されるのである。

<P>

　$ \ket{0}\bra{0} $や$ \ket{1}\bra{1} $は行列のようなものだとも考えられる。

<tex>
\ket{0}\bra{0} \ &=\ \left(\begin{array}{cc} 1 & 0 \\ 0 & 0 \end{array} \right) \\[5pt]
\ket{1}\bra{1} \ &=\ \left(\begin{array}{cc} 0 & 0 \\ 0 & 1 \end{array} \right) \\
</tex>

　これも普通に行列の計算をすれば確かにそうなっていると確認ができる。

<P>

　興味本位でCNOTゲートを全て行列で書いてみよう。
　$ \hat{U} $の代わりに X ゲートの演算子$ \hat{\sigma}_x $を使うのである。

<tex>
\hat{C} \ =\ 
\left(\begin{array}{cc} 1 & 0 \\ 0 & 0 \end{array} \right)
\left(\begin{array}{cc} 1 & 0 \\ 0 & 1 \end{array} \right) \ +\ 
\left(\begin{array}{cc} 0 & 0 \\ 0 & 1 \end{array} \right)
\left(\begin{array}{cc} 0 & 1 \\ 1 & 0 \end{array} \right)
</tex>

　これはこれ以上計算して簡略化しようとしてはいけないものである。
　各項の左側の行列は左側の状態にだけ、右側の行列は右側の状態にだけ働きかけるものだからである。
　つまり、次のような感じに使うのである。

<tex>
\hat{C} \ket{m} \ket{n} \ =\ 
\left(\begin{array}{cc} 1 & 0 \\ 0 & 0 \end{array} \right)\ket{m}
\left(\begin{array}{cc} 1 & 0 \\ 0 & 1 \end{array} \right) \ket{n}\ +\ 
\left(\begin{array}{cc} 0 & 0 \\ 0 & 1 \end{array} \right)\ket{m}
\left(\begin{array}{cc} 0 & 1 \\ 1 & 0 \end{array} \right)\ket{n} \tag{4}
</tex>

　これを使って何を試せば自分としては納得が行くだろうか。

% =======================================================================

\section{CNOTゲートを調べる}

　まずはエンタングル状態にない入力を試してみよう。

<tex>
\ket{m} \ =\ a \, \ket{0} \ +\ b \, \ket{1} \ =\ \left( \begin{array}{c} a \\[5pt] b \end{array} \right) \\
\ket{n} \ =\ c \, \ket{0} \ +\ d \, \ket{1} \ =\ \left( \begin{array}{c} c \\[5pt] d \end{array} \right)
</tex>

　$ \ket{m} $が制御ビットで、$ \ket{n} $が標的ビットだという想定である。
　これを (4) 式に代入すれば次のようになる。

<tex>
\hat{C} \ket{m} \ket{n} \ \ &=\ 
\left(\begin{array}{cc} 1 & 0 \\ 0 & 0 \end{array} \right)
\left( \begin{array}{c} a \\[3pt] b \end{array} \right)
\left(\begin{array}{cc} 1 & 0 \\ 0 & 1 \end{array} \right)
\left( \begin{array}{c} c \\[3pt] d \end{array} \right) \ +\ 
\left(\begin{array}{cc} 0 & 0 \\ 0 & 1 \end{array} \right)
\left( \begin{array}{c} a \\[3pt] b \end{array} \right)
\left(\begin{array}{cc} 0 & 1 \\ 1 & 0 \end{array} \right)
\left( \begin{array}{c} c \\[3pt] d \end{array} \right) \\[5pt]
&=\ 
\left( \begin{array}{c} a \\[5pt] 0 \end{array} \right)
\left( \begin{array}{c} c \\[5pt] d \end{array} \right) \ +\ 
\left( \begin{array}{c} 0 \\[5pt] b \end{array} \right)
\left( \begin{array}{c} d \\[5pt] c \end{array} \right) \\[5pt]
&=\ a \, \ket{0} \big( c\,\ket{0} + d\,\ket{1} \big) \ +\ 
b \, \ket{1} \big( d\,\ket{0} + c\,\ket{1} \big) \\[5pt]
&=\ ac \, \ket{0}\ket{0} \ +\ ad \, \ket{0}\ket{1} \ +\ bd \, \ket{1}\ket{0} \ +\ bc\,\ket{1}\ket{1} \tag{5}
</tex>

　なんだか良く分からないし、自分はこれで何をしたかったのだろうかと立ち尽くしてしまうような結果だ。
　ああ、思い出した。
　このようにCNOTゲートを通した結果が「制御ビットと標的ビットの積という形で表せる場合」と
「そうではなくエンタングル状態になる場合」の違いが
どこにあるのかを知っておきたかったのだ。
　どうすればいいだろうか？

<P>

　積で表せる場合というのは (1) 式のようになるはずだ。
　ところが今の結果の (5) 式はそれとは微妙に違っている。
　(5) 式が (1) 式の形式で表せる条件を知る必要があるが、両方の式が係数に同じ記号を使っているのが問題である。
　それぞれで違う記号を使って比較すればいいのだが、変数の数が多すぎて面倒くさい。
　そこで、うまくサボることを考えよう。
　まず、制御ビットが重ね合わせ状態でない場合はエンタングル状態にならないのは分かるので除外して考えることにしよう。
　また標的ビットが重ね合わせ状態でない場合のことも先ほど考えたし、それほど複雑ではなかった。
　制御ビットが重ね合わせ状態ならエンタングル状態になるのだった。
　そういうわけで、もっと面倒な場合だけに絞って考えてみることにする。
　つまり、制御ビットも標的ビットも重ね合わせ状態にある場合に限って調べるのである。
　規格化のことは後で調整してやればいいだけのことなので、$ a=1 $、$ c=1 $と仮定した上で考えてやればよくなる。
　つまり (5) 式は

<tex>
\ket{0}\ket{0} \ +\ d \, \ket{0}\ket{1} \ +\ bd \, \ket{1}\ket{0} + b\,\ket{1}\ket{1} 
</tex>

と表され、一方の (1) 式は

<tex>
\ket{0}\ket{0} \ +\ t \, \ket{0}\ket{1} \ +\ s \, \ket{1}\ket{0} \ +\ st \, \ket{1}\ket{1}
</tex>

という形式で表される。
　これらが同一になる条件を探ろう。
　と言っても、ここまで来ればもう簡単な問題であり、結果だけ書いてしまうと、
$ t = 1 ,\ b = s ,\ d = 1 $となる場合と$ t = -1,\ b = -s,\ d = -1 $となる場合の二通りしかない。

<P>

　前者はこういうことだ。
　規格化はせずに書くが、

<tex>
\ket{\psi_c} \ &=\ \ket{0} \ +\ s \ket{1} \\
\ket{\psi_t} \ &=\ \ket{0} \ +\ \ket{1}
</tex>

という入力に対して出力は

<tex>
\ket{0}\ket{0} \ +\ \ket{0}\ket{1} \ +\ s \, \ket{1}\ket{0} \ +\ s \, \ket{1}\ket{1} 
</tex>
\

となり、これは

<tex>
\ket{\psi_c} \ &=\ \ket{0} \ +\ s \ket{1} \\
\ket{\psi_t} \ &=\ \ket{0} \ +\ \ket{1}
</tex>

の積として書ける。
　要するに、制御ビットも標的ビットもどちらも何も変化せずに出てくるパターンだ。
　$ s $は複素数であり、規格化もしていないのだから$ \ket{\psi_c} $としてはあらゆる状況が当てはまる。
　つまり標的ビット$ \ket{\psi_t} $がこの形をしているときに限っては、
制御ビットがどんな形をしていようが関係なく何も起こらないということである。
　考えてみれば当たり前なのかもしれない。
　標的ビットがこの形なら、反転させても何も変化しないのだから。

<P>

　次に後者を考えてみよう。
　こちらは

<tex>
\ket{\psi_c} \ &=\ \ket{0} \ -\ s \ket{1} \\
\ket{\psi_t} \ &=\ \ket{0} \ -\ \ket{1}
</tex>

という入力に対して出力は

<tex>
\ket{0}\ket{0} \ -\ \ket{0}\ket{1} \ +\ s \, \ket{1}\ket{0} \ -\ s \, \ket{1}\ket{1} 
</tex>
\

となり、これは

<tex>
\ket{\psi_c} \ &=\ \ket{0} \ +\ s \ket{1} \\
\ket{\psi_t} \ &=\ \ket{0} \ -\ \ket{1}
</tex>

の積として書けるということだ。
　入力の$ \ket{\psi_c} $の$ s $にマイナスが付いているが、$ s $は複素数でどんな数でもいいので、
実はあらゆる状況が当てはまる。
　つまり標的ビット$ \ket{\psi_t} $がこの形をしているときに限っては、
制御ビットがどんな形をしていようが関係なく、制御ビットの方の位相が逆転するということである。
　\red{なんと、標的ビットは変化しないで、制御ビットの方が変化を受けて出てきてしまうのだ！}

<P>

　こうして、制御ビットは変化しないという最初の説明は便宜的なものであって、全く正しくないことが分かる。
　とは言っても、こんな劇的なことが起こるのはこのような特殊な場合だけである。

<P>

　そして、これら以外のほとんどの場合には制御ビットと標的ビットの状態は分離して考えることが出来なくなるわけである。

% =======================================================================

\section{もう少し調べてみる}

　既にエンタングル状態にあるものがCNOTゲートに入力されたら、何か面白いことが起こるのだろうか？
　その辺りも試しておこう。
　エンタングル状態とそれ以外の状態を判断するのは面倒なので、あらゆる状況を表した (3) 式を使ってみよう。
　つまり、(4) 式に (3) 式を代入するのである。

<tex>
\hat{C} \ket{\Psi} \ &=\ \hat{C} \big( \alpha \, \ket{0}\ket{0} \ +\ \beta \, \ket{0}\ket{1} \ +\ \gamma \, \ket{1}\ket{0} \ +\ \delta \, \ket{1}\ket{1} \big) \\[3pt]
&=\ \alpha \, \hat{C} \ket{0}\ket{0} \ +\ \beta \, \hat{C} \ket{0}\ket{1} \ +\ \gamma \, \hat{C} \ket{1}\ket{0} \ +\ \delta \, \hat{C} \ket{1}\ket{1} \\[3pt]
&=\ \alpha \, \ket{0}\ket{0} \ +\ \beta \, \ket{0}\ket{1} \ +\ \gamma \, \ket{1}\ket{1} \ +\ \delta \, \ket{1}\ket{0} \\[3pt]
&=\ \alpha \, \ket{0}\ket{0} \ +\ \beta \, \ket{0}\ket{1} \ +\ \delta \, \ket{1}\ket{0} \ +\ \gamma \, \ket{1}\ket{1} \tag{6}
</tex>

　こうしてみるととても単純である。
　第 3 項と第 4 項の係数が入れ替わるだけだ。
　分かりやすい法則だが、これだけのことに何か面白い応用があったりするものだろうか？


% =======================================================================

\section{交換ゲート}

　3 つのCNOTゲートを次のように接続してみよう。

\image{./computer4/swap1.png,交換ゲートの回路図}

　2 段目では制御ビットを標的ビットとして入れて、標的ビットを制御ビットとして入れている。
　とてもややこしいことが起こりそうだ。

<P>

　ところがそうでもない。
　これまでは$ \ket{\Psi} $を表す時に制御ビットの方を先に書くという考え方をしてきたのだった。
　しかしその考え方に縛られるのはやめて、
図の上側にある量子ビット$ \ket{m} $を先に書いて下側にある量子ビット$ \ket{n} $を後に書いて
全体の状態を$ \ket{m}\ket{n} $と表すという考えに移行してみよう。
　その上で (6) 式を見直してみる。

<P>

　(6) 式では制御ビットが$ \ket{1} $になっている項どうしの係数が入れ替わっていたのだった。
　今問題にしている 2 段目の逆立ちしたCNOTゲートでは制御ビットが後ろ側に書かれていることになるので、
第 2 項と第 4 項の係数を入れ替えるようにすれば、ここで起きることが説明できる。

<P>

　そこで全体で起きることを考えてみよう。
　最初は次のような状態だったとする。

<tex>
\ket{\Psi} \ =\ \alpha \, \ket{0}\ket{0} \ +\ \beta \, \ket{0}\ket{1} \ +\ \gamma \, \ket{1}\ket{0} \ +\ \delta \, \ket{1}\ket{1} 
</tex>

　まず第 3 項と第 4 項の係数を入れ替える。

<tex>
\ket{\Psi} \ =\ \alpha \, \ket{0}\ket{0} \ +\ \beta \, \ket{0}\ket{1} \ +\ \delta \, \ket{1}\ket{0} \ +\ \gamma \, \ket{1}\ket{1} 
</tex>

　これが第 1 のゲートを抜けてきた後の状態であり、(6) 式と同じである。
　次は第 2 項と第 4 項の係数を入れ替える。

<tex>
\ket{\Psi} =\ \alpha \, \ket{0}\ket{0} \ +\ \gamma \, \ket{0}\ket{1} \ +\ \delta \, \ket{1}\ket{0} \ +\ \beta \, \ket{1}\ket{1}
</tex>

　これが 2 段目のゲートを抜けてきた後の状態だ。
　そして再び第 3 項と第 4 項の係数を入れ替える。
　結果は次のようになるだろう。

<tex>
\ket{\Psi} =\ \alpha \, \ket{0}\ket{0} \ +\ \gamma \, \ket{0}\ket{1} \ +\ \beta \, \ket{1}\ket{0} \ +\ \delta \, \ket{1}\ket{1}
</tex>

　結局、一番最初の状態と比べると第 2 項と第 3 項だけが入れ替わった形だ。
　これは、二つの量子ビットを並べる順を逆にしてみてから項を並べ替えたのと同じことでもある。
　つまり、それぞれの量子ビットの役割を入れ替えたことに相当する。

\image{./computer4/swap2.png,交換ゲートを通ったあとの結果を書き入れた図}

　このようなゲートに通すと、二つの量子ビットの量子状態をすっかり入れ替えたのと同じことが起きるわけだ。
　この組み合わせで作ったゲートは「\red{交換ゲート}」あるいは「\red{スワップゲート}」と呼ばれる。

<P>

　わざわざこんなゲートの組み合わせを使わなくても、ただ配線を入れ替えれば済むだけにも思える。
　しかしゲート式の量子コンピュータは量子ビットを保持した何物かを移動させる方式のものばかりではない。
　鎮座して在（ましま）す量子ビットに対して外から次々と働きかける方式もある。
　前者を「\red{弾道型}」、後者を「\red{固定型}」と分類したりする。

<P>

　二つの量子状態を入れ替えるのにこのような方法もあるという提案は設計の幅を広げてくれるだろう。
　実用的な意味がなかったとしても、これはこれで理論的にも面白い。

<P>

　毎回このような 3 つのCNOTゲートを描くのは面倒なので、
交換ゲートを意味する次のような略記号も良く使われている。

\image{./computer4/swap3.png,交換ゲートの図記号}

　左側は制御 X ゲートが両方向に使われているといういかにも複雑な感じが出ているし、
右側は経路を入れ替えれば済むだけだといういかにも軽い感じが出ている。
　しかしどちらも等価でありただの記号なので、
微妙なニュアンスなどは気にしてもしなくてもいいので好きな方を使えばいいと思う。

% =======================================================================

\section{万能性}

　ここまでCNOTゲートの話ばかりを書いてきた。
　しかしCNOTゲートは最初に話した一般的な制御ユニタリゲートのうちで最も単純な例に過ぎないというのだから、
いかにもじれったく感じることだろう。

<P>

　ところがそうでもなく、実はCNOTゲートと、1 量子ビットに対するユニタリゲートを組み合わせれば、
どんな制御ユニタリゲートでも実現できてしまうのである。
　前回は 1 量子ビットに対するユニタリゲートは位相ゲートとアダマールゲートで実現できるという話をした。
　つまり結局のところ、位相ゲートとアダマールゲートとCNOTゲートがあれば、
どんな制御ユニタリゲートでも作れてしまうのである。

<P>

　具体的にどうやればいいのかと気になる人も多いと思うが、
今回の話は既にかなり長くなってしまっているのでその話は次回にしよう。

<P>

　ついでだからさらに衝撃的なことを先走って話しておこう。
　今のところ 2 つの量子ビットに対する操作の話しかしていない。
　しかし量子ビットの数がどれだけ増えても、それらに対するユニタリ的な操作は
これらのゲートの組み合わせで実現できることが知られている。

<P>

　\red{つまり、これで量子的な万能ゲートが出揃ったことになるわけだ。}
　あとはもう読者の知恵と工夫次第でゲートを組み合わせて、
どんな計算ができるか無限の可能性を追求してくれたまえ。
　……と言いたいところだが、それではあまりにも不親切なのでもう少し話が続くことになる。
　全部で 4、5 回の話にするつもりだったのだが、かなりの予定オーバーになりそうである。


